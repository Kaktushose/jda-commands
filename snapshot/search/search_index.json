{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"JDA-Commands","text":"<p>A declarative, annotation driven interaction framework for JDA. Our goal is to remove any boilerplate code, so  you can focus solely on the business logic of your bot - writing bots has never been easier:</p> CodeExecution <pre><code>@Interaction\npublic class CookieClicker {\n\n    private int counter;//(1)!\n\n    @Command(value = \"cookie clicker\", desc = \"Play cookie clicker\")\n    public void onClicker(CommandEvent event) {\n        event.with().components(\"onCookie\").reply(\"You've got { $count } cookie(s)!\", entry(\"count\", counter));\n    }\n\n    @Button(value = \"Collect\", emoji = \"\ud83c\udf6a\", style = ButtonStyle.SUCCESS)\n    public void onCookie(ComponentEvent event) {\n        event.reply(\"You've got { $count } cookie(s)!\", entry(\"count\", counter++));//(2)!\n    }\n}\n</code></pre> <ol> <li>Yes, that's right! We can store the <code>counter</code> as a class variable. JDA-Commands will create a new instance of   <code>CookieClicker</code> for every command execution, so you don't need to worry about state. You can read more about    it here.</li> <li>This will edit the original message and will also keep the <code>\ud83c\udf6a Collect</code> button attached. You can find find more    about building replies here.</li> </ol> <p></p>"},{"location":"#adding-to-your-project","title":"Adding to your Project","text":"MavenGradle (Kotlin DSL)Gradle (Groovy DSL) pom.xml<pre><code>&lt;dependency&gt;\n   &lt;groupId&gt;io.github.kaktushose&lt;/groupId&gt;\n   &lt;artifactId&gt;jda-commands&lt;/artifactId&gt;\n   &lt;version&gt;4.0.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> build.gradle.kts<pre><code>repositories {\n   mavenCentral()\n}\ndependencies {\n   implementation(\"io.github.kaktushose:jda-commands:4.0.1\")\n}\n</code></pre> build.gradle<pre><code>repositories {\n   mavenCentral()\n}\ndependencies {\n   implementation 'io.github.kaktushose:jda-commands:4.0.1\"'\n}\n</code></pre>"},{"location":"#additional-resources","title":"Additional Resources","text":"<p>You might also find the following resources helpful:</p> <ul> <li>Javadocs</li> <li>Release Notes</li> <li>JDA Wiki</li> </ul> <p>Having trouble or found a bug?</p> <ul> <li>Check out the Examples</li> <li>Join our Discord Server</li> <li>Or open an Issue</li> </ul>"},{"location":"di/","title":"Dependency Injection","text":"<p>Dependency injection supports the dependency inversion principle by injecting dependencies into the class definitions  instead of hardcoding them. You'll need dependency injection when using JDA-Commands, because most of your classes, like interaction controllers or middlewares aren't instantiated by  you anymore. </p> <p>JDA-Commands creates one instance of an interaction controller class per runtime. To allow the injection of own Objects in these instances, JDA-Commands provides an interface to integrate a dependency injection framework.</p> <p>Tip</p> <p>Since JDA-Commands is a fundamental part of your discord bot and dependency injection is deeply connected with it, your bot should use a dependency injection framework for all your tasks.</p>"},{"location":"di/#default-dependency-injection-framework-guice","title":"Default Dependency Injection Framework - Guice","text":"<p>Warning</p> <p>For information on how to use Googles Guice, please visit their documentation. This wiki only covers the configuration part. </p> <p>If your using JDA-Commands via the <code>io.github.kaktushose:jda-commands:VERSION</code> artifact, an integration for  Googles Guice is shipped by default. </p> <p>To customize this integration you can pass an instance of <code>GuiceExtensionData</code> to the JDA-Commands builder, which allows you to provide an own instance of Guices Injector.</p> <p>Configuring Guice</p> <pre><code>Injector yourInjector = Guice.createInjector(new YourOwnGuiceModule());\n\nJDACommands.builder(jda, Main.class)\n        .extensionData(new GuiceExtensionData(yourInjector))\n        .start();\n</code></pre> <p>JDA Object</p> <p>The <code>JDA</code> instance is provided by JDA-Commands and can be obtained via Guice. <pre><code>@Interaction\npublic class GreetCommand {\n\n    private final JDA jda;\n\n    @Inject\n    public GreetCommand(JDA jda) {\n        this.jda = jda;\n    }\n\n    @Command(\"greet\")\n    public void onCommand(CommandEvent event) { ... }\n}\n</code></pre></p>"},{"location":"di/#implementation-annotation","title":"<code>@Implementation</code> annotation","text":"<p>JDA-Commands has many interfaces to customize specific framework behaviour.  If you're using the Guice integration you can benefit from the convenient <code>Implementation</code> annotation. </p> <p>This annotation allows the automatic instantiation and registration for implementations of following interfaces:</p> <p>Note</p> <p>If you're annotating an implementation of <code>Middleware</code>, <code>Validator</code> or <code>TypeAdapter</code> you have to provide additional configuration via the <code>@Implementation</code> annotation.</p> <ul> <li><code>PermissionsProvider</code></li> <li><code>GuildScopeProvider</code></li> <li><code>ErrorMessageFactory</code></li> <li> <p><code>Descriptor</code></p> </li> <li> <p><code>Middleware</code> + <code>Implementation.Middleware#priority()</code> set</p> </li> <li><code>Validator</code> + <code>Implementation.Validator#annotation()</code> set</li> <li><code>TypeAdapter</code> + <code>Implementation.TypeAdapter#source()</code> &amp; <code>Implementation.TypeAdapter#target()</code> set</li> </ul> <p>The annotated classes will be instantiated with help of <code>com.google.inject.Injector</code> similar to interaction controllers.</p> <p>Example</p> <pre><code>@Implementation\npublic class CustomGuildScopeProvider implements GuildScopeProvider {\n\n    private final Database database;\n\n    @Inject\n    public HelloWord(Database database) {\n        this.database = database;\n    }\n\n    public Set&lt;Long&gt; apply(CommandData data) { \n        return database.getGuildsForCommand(data);\n    }\n}\n</code></pre>"},{"location":"di/#custom-dependency-injection-integrations","title":"Custom dependency injection integrations","text":"<p>If you want to integrate another dependency injection framework, you have to provide your own  implementation of <code>InteractionControllerInstantiator</code>.</p> <p>You can do this by either passing it to the builder or by creating your own extension.</p> <p>Example</p> <pre><code>JDACommands.builder(jda, Main.class)\n        .instanceProvider(new OwnInterationControllerInstantiator(someContext))\n        .start();\n</code></pre>"},{"location":"interactions/commands/","title":"Commands","text":"<p>Info</p> <p>If you're new to JDA and Discord Bots in general, please make yourself familiar with the JDA wiki first. We assume that the basic structure of interactions is known.</p>"},{"location":"interactions/commands/#slash-commands","title":"Slash Commands","text":"<p>SlashCommands are defined by annotating a method with <code>Command</code>. The first parameter must always be a <code>CommandEvent</code>. The name and other metadata of the command is passed to the annotation. <pre><code>@Command(value = \"example\", desc = \"This is an example command\")\npublic void onCommand(CommandEvent event) {...}\n</code></pre></p>"},{"location":"interactions/commands/#sub-commands-sub-command-groups","title":"Sub Commands &amp; Sub Command Groups","text":"<p>In contrast to JDA, JDA-Commands doesn't differentiate between slash commands, sub command groups and sub commands. JDA-Commands determines the type automatically based on the command names. </p> <p>Let's say we have the following commands in our moderation bot: <pre><code>@Command(\"delete\")\npublic void onDeleteMessages(CommandEvent event) {...}\n\n@Command(\"moderation warn\")\npublic void onWarnMember(CommandEvent event) {...}\n\n@Command(\"moderation kick\")\npublic void onKickMember(CommandEvent event) {...}\n\n@Command(\"moderation ban\")\npublic void onBanMember(CommandEvent event) {...}\n</code></pre> JDA-Commands will create a tree structure of these commands. A depth-first-search is then performed to determine which  commands should be registered as a slash command, a sub command or a sub command group. <pre><code>\u251c\u2500\u2500 delete\n\u2514\u2500\u2500 moderation\n    \u251c\u2500\u2500 warn\n    \u251c\u2500\u2500 kick\n    \u2514\u2500\u2500 ban\n</code></pre></p> Debugging <p>JDA-Commands will log this tree on log-level <code>DEBUG</code>. This might help you with debugging, for example when a command  doesn't show up.</p> <p>In our example the following commands will be registered: </p> <ul> <li><code>/delete</code></li> <li><code>/moderation warn</code></li> <li><code>/moderation kick</code></li> <li><code>/moderation ban</code></li> </ul> <p>To simplify things, you can also use the <code>Interaction</code> to add a base name to all slash commands in a command controller: <pre><code>@Interaction(\"moderation\")\npublic class ModerationCommands {\n\n    @Command(\"warn\")\n    public void onWarnMember(CommandEvent event) {...}\n\n    @Command(\"kick\")\n    public void onKickMember(CommandEvent event) {...}\n\n    @Command(\"ban\")\n    public void onBanMember(CommandEvent event) {...}\n}\n</code></pre></p>"},{"location":"interactions/commands/#command-options","title":"Command Options","text":"<p>You can add command options by simply adding a parameter to the method. <pre><code>@Command(\"ban\")\npublic void onBanMember(CommandEvent event, Member target, String reason, int delDays) {\n    (...)\n}\n</code></pre> JDA-Commands will attempt to type adapt the command options. You can find a concrete list of all supported type adapters  here.</p> <p>You can also register your own type adapters.</p>"},{"location":"interactions/commands/#optiontype","title":"OptionType","text":"<p>The parameters will automatically be mapped to the best fitting <code>OptionType</code>, defaulting to <code>OptionType#STRING</code>. You can override this mapping by using the  <code>Param</code> annotation.  <pre><code>@Command(\"ban\")\npublic void onBanMember(CommandEvent event, @Param(type = OptionType.USER) IMentionable target) {\n    (...)\n}\n</code></pre></p>"},{"location":"interactions/commands/#name-description","title":"Name &amp; Description","text":"<p>Use the <code>Param</code> annotation to set a name and a description  for a command option. By default, the parameter name will be used as the option name. <pre><code>@Command(\"ban\")\npublic void onBanMember(CommandEvent event, \n                        @Param(\"The member to ban\") Member target,\n                        @Param(\"The reason to ban the member\") String reason,\n                        @Param(name = \"deletion days\", value = \"The number of days to delete messages for\") int delDays) {\n    (...)\n}\n</code></pre></p> <p>Danger</p> <p>In order for JDA-Commands to use the parameter name as the command option name, you must enable the <code>-parameters</code> compiler flag.</p> MavenGradle (Kotlin DSL)Gradle (Groovy DSL)IntelliJ pom.xml<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n    &lt;configuration&gt;\n        &lt;compilerArgs&gt;\n            &lt;compilerArg&gt;-parameters&lt;/compilerArg&gt;\n        &lt;/compilerArgs&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre> build.gradle.kts<pre><code>tasks.withType&lt;JavaCompile&gt; {\n    options.compilerArgs += \"-parameters\"\n}\n</code></pre> build.gradle<pre><code>compileJava {\n    options.compilerArgs &lt;&lt; '-parameters'\n}\n</code></pre> <p>If you compile your project with IntelliJ during development go to <code>Settings &gt; Compiler &gt; Java Compiler</code> and add the <code>-parameters</code> flag:</p> <p></p>"},{"location":"interactions/commands/#optional","title":"Optional","text":"<p>In order to make a command option optional, annotate the parameter with <code>Param</code>. <pre><code>@Command(\"ban\")\npublic void onBanMember(CommandEvent event, Member target, @Param(optional = true) String reason, @Param(optional = true) int delDays) {\n    (...)\n}\n</code></pre></p> <p>Alternatively, you can wrap the parameter in an <code>Optional</code>. <pre><code>@Command(\"ban\")\npublic void onBanMember(CommandEvent event, Member target, Optional&lt;String&gt; reason, Optional&lt;Integer&gt; delDays) {\n    (...)\n}\n</code></pre></p> <p>Note</p> <p>Required options must be added before non-required options.</p>"},{"location":"interactions/commands/#choices","title":"Choices","text":"<p>Use the <code>Choices</code> annotation to add choices to a command option: <pre><code>@Command(\"ban\")\npublic void onBanMember(CommandEvent event, \n                        Member target, \n                        @Choices({\"Harassment\", \"Scam\", \"Advertising\"}) String reason, \n                        int delDays) {\n    (...)\n}\n</code></pre> The example above will use the given String for both the <code>name</code> and the <code>value</code>. You can use the <code>name:value</code> format to specify both: <pre><code>@Command(\"ban\")\npublic void onBanMember(CommandEvent event, \n                        Member target, \n                        @Choices({\"Harassment:reason_1\", \"Scam:reason_2\", \"Advertising::reason_3\"}) String reason, \n                        int delDays) {\n    (...)\n}\n</code></pre></p>"},{"location":"interactions/commands/#auto-complete","title":"Auto Complete","text":"<p>You can add auto complete to a command option by defining an auto complete handler for it by annotating a method with <code>AutoComplete</code>. Auto Complete handlers are always bound to  one or more slash commands. </p> <p>The slash commands can either be referenced by the:</p> <ol> <li> <p>Command Name</p> <p>If referenced by the command name, the handler will handle any command whose name starts with the given name:</p> <p>Example</p> <pre><code>@Command(\"favourite fruit\")\n    public void fruitCommand(CommandEvent event, String fruit) {\n    event.reply(\"You've chosen: %s\", fruit);\n}\n\n@Command(\"favourite vegetable\")\npublic void vegetableCommand(CommandEvent event, String vegetable) {\n    event.reply(\"You've chosen: %s\", vegetable);\n}\n\n@AutoComplete(\"favourite\") //(1)!\npublic void onFavouriteAutoComplete(AutoCompleteEvent event) {\n    event.replyChoices(...);\n}\n</code></pre> <ol> <li>This auto complete handler will receive auto complete events for both <code>/favourite fruit</code> and <code>/favourite vegetable</code></li> </ol> <p>It is also possible to reference the commands by their full name:</p> <p>Example</p> <pre><code>@AutoComplete({\"favourite fruit\", \"favourite vegtable\"})\npublic void onFavouriteAutoComplete(AutoCompleteEvent event) {\n    event.replyChoices(...);\n}\n</code></pre> </li> <li> <p>Method Name</p> <p>If referenced by the method name the handler will only handle the slash command of the given method:</p> <p>Example</p> <pre><code>@Command(\"favourite fruit\")\npublic void fruitCommand(CommandEvent event, String fruit) {\n    event.reply(\"You've chosen: %s\", fruit);\n}\n\n@AutoComplete(\"fruitCommand\") //(1)!\npublic void onFruitAutoComplete(AutoCompleteEvent event) {\n    event.replyChoices(...);\n}    \n</code></pre> <ol> <li>This auto complete handler will only receive auto complete events for <code>/favourite fruit</code>!</li> </ol> </li> </ol> <p>Warning</p> <p>If an auto complete handler doesn't specify any command options, it will be registered implicitly for every command option of the given slash command(s)!</p> <p>So far we haven't specified which command options should have auto complete, resulting in every command option having  auto complete enabled. If you want to avoid that, you have to explicitly state the command options the handler supports:</p> <p>Example</p> <pre><code>@Command(\"favourite food\")\npublic void foodCommand(CommandEvent event, String fruit, String vegetable) {\n    event.reply(\"You've chosen: %s and %s\".formatted(fruit, vegetable));\n}\n\n@AutoComplete(vale = \"foodCommand\", options = \"fruit\")\npublic void onFruitAutoComplete(AutoCompleteEvent event) {\n    event.replyChoices(...);\n}\n</code></pre> <p>You can have multiple auto complete handler for the same slash command, but each command option can only have exactly  one handler. An auto complete handler that explicitly supports a command option will always be called over a handler  that is implicitly registered.</p>"},{"location":"interactions/commands/#min-max-value","title":"Min &amp; Max Value","text":"<p>Use the <code>Min</code> or <code>Max</code> annotation to set the minimum and maximum value for numeral options. </p> <p>Example</p> <pre><code>@Command(\"ban\")\npublic void onBanMember(CommandEvent event, Member target, String reason, @Max(7) int delDays) {\n    (...)\n}\n</code></pre>"},{"location":"interactions/commands/#context-commands","title":"Context Commands","text":"<p>Both types of context commands are defined by the same <code>Command</code> annotation. The first parameter must always be a <code>CommandEvent</code>. The name and other metadata of the command is passed to the annotation.</p>"},{"location":"interactions/commands/#message-context","title":"Message Context","text":"<p>For message context commands the second method parameter must be a <code>Message</code> and the <code>type</code> must be <code>Command.Type#MESSAGE</code>. <pre><code>@Command(value = \"Delete this message\", type = Command.Type.MESSAGE)\npublic void onDeleteMessage(CommandEvent event, Message target) { ... }\n</code></pre></p>"},{"location":"interactions/commands/#user-context","title":"User Context","text":"<p>For user context commands the second method parameter must be a <code>User</code> and the <code>type</code> must be <code>Command.Type#USER</code>. <pre><code>@Command(value = \"Ban this user\", type = Command.Type.USER)\npublic void onBanMember(CommandEvent event, User user) { ... }\n</code></pre></p> <p>Alternatively, you can also use <code>Member</code> in the method signature. However, this only works for  <code>InteractionContextType#GUILD</code>.</p> <pre><code>@Command(value = \"Ban this user\", type = Command.Type.USER)\n@CommandConfig(context = InteractionContextType.GUILD) // default value\npublic void onBanMember(CommandEvent event, Member member) { ... }\n</code></pre>"},{"location":"interactions/commands/#additional-settings","title":"Additional Settings","text":"<p>Use the <code>CommandConfig</code> annotation to configure the  following settings. You can either annotate a command method directly or annotate the interaction controller class. It  is also possible to set a global command config at the builder:</p> <p>Global CommandConfig</p> <pre><code>JDACommands.builder(jda, Main.class)\n    .globalCommandConfig(CommandConfig.of(config -&gt; config.nsfw(true))\n    .start();\n</code></pre> <p>JDA-Commands will apply clashing CommandConfigs in the following hierarchy:</p> <ol> <li><code>CommandConfig</code> method annotation</li> <li><code>CommandConfig</code> class annotation</li> <li>global <code>CommandConfig</code></li> </ol>"},{"location":"interactions/commands/#enabledfor","title":"enabledFor","text":"<p>Sets the <code>Discord Permissions</code> a command will be enabled for. By default, a command  will be enabled for every permission.</p> <p>Danger</p> <p>Guild admins can modify these permissions at any time! If you want to enforce permissions or secure a critical command further you should use the permissions system of JDA-Commands. You can read more about it here.</p> <pre><code>@CommandConfig(enabledFor = Permission.BAN_MEMBERS)\n@Command(value = \"example\")\npublic void onCommand(CommandEvent event) {...}\n</code></pre>"},{"location":"interactions/commands/#context","title":"context","text":"<p>Sets the <code>InteractionContextTypes</code> of a command. The default value is <code>InteractionContextType#GUILD</code>.</p> <pre><code>@CommandConfig(context = {InteractionContextType.GUILD, InteractionContextType.BOT_DM})\n@Command(value = \"example\")\npublic void onCommand(CommandEvent event) {...}\n</code></pre>"},{"location":"interactions/commands/#integration","title":"integration","text":"<p>Sets the <code>IntegrationTypes</code> of a command. The default value is <code>IntegrationType#GUILD_INSTALL</code>.</p> <pre><code>@CommandConfig(integration = {IntegrationType.GUILD_INSTALL, IntegrationType.USER_INSTALL})\n@Command(value = \"example\")\npublic void onCommand(CommandEvent event) {...}\n</code></pre>"},{"location":"interactions/commands/#isnsfw","title":"isNSFW","text":"<p>Sets whether a command can only be executed in NSFW channels. The default value is <code>false</code>.</p> <pre><code>@CommandConfig(isNSFW = true)\n@Command(value = \"example\")\npublic void onCommand(CommandEvent event) {...}\n</code></pre>"},{"location":"interactions/commands/#scope-guild-global-commands","title":"scope (Guild &amp; Global Commands)","text":"<p>Sets whether a command should be registered as a <code>global</code> or as a <code>guild</code> command. The default value is <code>global</code>.</p> <pre><code>@CommandConfig(scope = CommandScope.GUILD)\n@Command(value = \"example\")\npublic void onCommand(CommandEvent event) {...}\n</code></pre> <p>When having guild scoped commands you have to use the <code>GuildScopeProvider</code> to  tell JDA-Commands what guilds a command should be registered for. </p> <p>Let's say we have a paid feature in our bot:</p> <p>Example</p> <pre><code>@CommandConfig(scope = CommandScope.GUILD)\n@Command(value = \"paid feature\")\npublic void onCommand(CommandEvent event) {\n    event.reply(\"Hello World!\");\n}\n</code></pre> <p>We then need to implement a <code>GuildScopeProvider</code> to only register this command for guilds that have paid for that feature:</p> <p>Example</p> <pre><code>public class PremiumGuildsProvider implements GuildScopeProvider {\n\n    @Override\n    public Set&lt;Long&gt; apply(CommandData commandData) {\n        if (commandData.getName().equals(\"paid feature\")) {\n            // this is the place where you could also perform a database lookup\n            return Set.of(1234567890L);\n        }\n        return Set.of();\n    }\n}\n</code></pre> <p>Finally, we have to register our <code>PremiumGuildsProvider</code> either at the builder or by annotating it with <code>Implementation</code>.</p> <p>Example</p> <code>@Implementation</code>Builder Registration <pre><code>@Implementation\npublic class PremiumGuildsProvider implements GuildScopeProvider {\n    ...\n}\n</code></pre> <pre><code>JDACommands.builder(jda, Main.class)\n    .guildScopeProvider(new PremiumGuildsProvider())\n    .start();\n</code></pre> <p>Note</p> <p>Using the <code>Implementation</code> annotation requires the guice integration  (shipped by default). You can read more about it here.   </p>"},{"location":"interactions/components/","title":"Components","text":"<p>Note</p> <p>This section only covers how you define components. See the Reply API section to learn how to use them in replies.</p>"},{"location":"interactions/components/#localization-and-placeholders","title":"Localization and Placeholders","text":"<p>To avoid hardcoded values, all string values of an annotation can be replaced by a localization key as supported by the current used Localization System.</p> <p>Furthermore, it's possible to directly use placeholders. For more information on how to use placeholders please visit this page.</p> <p>Also take a look at the general message resolution documentation.</p> <p>Example (with Fluava)</p> <pre><code>@Button(value = \"my.localization.key\", style = ButtonStyle.DANGER, link = \"{ $jdac_link }\")\npublic void onButton(ComponentEvent event) {...}\n</code></pre> <p>The Dollar Sign ($)</p> <p>The dollar sign is a reserved character for bundle name separation. In most cases that shouldn't bother you but if you encounter any problems, please read the notes here.</p>"},{"location":"interactions/components/#unicode-and-application-emojis","title":"Unicode and application emojis","text":"<p>JDA-Commands has built in support for Unicode and application emoji aliases. If you want to use them, just take a look here.</p>"},{"location":"interactions/components/#buttons","title":"Buttons","text":"<p>Buttons are defined by annotating a method with <code>Button</code>.  The first parameter must always be a <code>ComponentEvent</code>. The label and other metadata of the button is passed to the annotation. <pre><code>@Button(\"example\")\npublic void onButton(ComponentEvent event) {...}\n</code></pre></p>"},{"location":"interactions/components/#style","title":"style","text":"<p>Sets the style of a button.</p> <p></p> <p>Example</p> <pre><code>@Button(value = \"example\", style = ButtonStyle.DANGER)\npublic void onButton(ComponentEvent event) {...}\n</code></pre> <p>Note</p> <p><code>ButtonStyle#PREMIUM</code> is not supported by JDA-Commands.</p>"},{"location":"interactions/components/#emoji","title":"emoji","text":"<p>Sets the emoji of a button.</p> <p>Example</p> <pre><code>@Button(value = \"Emoji\", emoji = \"\ud83e\udd17\")\npublic void onButton(ComponentEvent event) {...}\n</code></pre>"},{"location":"interactions/components/#link","title":"link","text":"<p>Buttons that have a link cannot be executed, but they are still defined like normal buttons.</p> <p>Example</p> <pre><code>@Button(value = \"JDA-Commands Wiki\", link = \"https://kaktushose.github.io/jda-commands/wiki/\")\npublic void onButton(ComponentEvent event) { }\n</code></pre>"},{"location":"interactions/components/#select-menus","title":"Select Menus","text":""},{"location":"interactions/components/#string-select-menus","title":"String Select Menus","text":"<p>String Select Menus are defined by annotating a method with <code>StringSelectMenu</code> The first parameter must always be a <code>ComponentEvent</code>. The second parameter must be a <code>List</code>.</p> <p>The placeholder and other metadata of the String Select Menu is passed to the annotation. </p> <p>Select Options are defined by annotating the method with <code>MenuOption</code>.</p> <p>Example</p> <pre><code>@MenuOption(label= \"Pizza\", value = \"pizza\")\n@MenuOption(label= \"Hamburger\", value = \"hamburger\")\n@MenuOption(label= \"Sushi\", value = \"Sushi\")\n@StringSelectMenu(\"What's your favourite food?\")\npublic void onMenu(ComponentEvent event, List&lt;String&gt; choices) { ... }\n</code></pre>"},{"location":"interactions/components/#min-max-value","title":"Min &amp; Max Value","text":"<p>String Select Menus support up to 25 options. You can set the minimum and maximum value by using the <code>minValue</code> and  <code>maxValue</code> fields.</p> <p>Example</p> <pre><code>@SelectOption(label= \"Pizza\", value = \"pizza\")\n@SelectOption(label= \"Hamburger\", value = \"hamburger\")\n@SelectOption(label= \"Sushi\", value = \"Sushi\")\n...\n@StringSelectMenu(value = \"What's your favourite food?\", minValue = 2, maxValue = 4)\npublic void onMenu(ComponentEvent event, List&lt;String&gt; choices) { ... }\n</code></pre>"},{"location":"interactions/components/#entity-select-menus","title":"Entity Select Menus","text":"<p>Entity Select Menus are defined by annotating a method with <code>EntitySelectMenu</code>. The first parameter must always be a <code>ComponentEvent</code>. The second parameter must be of type <code>Mentions</code>.</p> <p>Example</p> <pre><code>@EntitySelectMenu(value = SelectTarget.USER, placeholder = \"Who's your favourite user?\")\npublic void onMenu(ComponentEvent event, Mentions mentions) { ... }\n</code></pre>"},{"location":"interactions/components/#channel-types","title":"Channel Types","text":"<p>When using <code>SelectTarget.CHANNEL</code> you can limit the selectable channel types with the <code>channelTypes</code> field.</p> <p>Example</p> <pre><code>@EntitySelectMenu(\n            value = SelectTarget.CHANNEL, \n            placeholder = \"What's your favourite channel?\", \n            channelTypes = {ChannelType.TEXT, ChannelType.VOICE}\n)\npublic void onMenu(ComponentEvent event, Mentions mentions) { ... }\n</code></pre>"},{"location":"interactions/components/#default-values","title":"Default Values","text":"<p>You can set the default values of the Entity Select Menu by using respectively the <code>defaultChannels</code>, <code>defaultRoles</code> or <code>defaultUsers</code> fields. </p> <p>Example</p> <pre><code>@EntitySelectMenu(\n            value = SelectTarget.CHANNEL, \n            placeholder = \"What's your favourite channel?\",\n            defaultChannels = {0123456789L, 9876543210L}\n)\npublic void onMenu(ComponentEvent event, Mentions mentions) { ... }\n</code></pre>"},{"location":"interactions/components/#min-max-value_1","title":"Min &amp; Max Value","text":"<p>Just as for String Select Menus you can set the minimum and maximum value by using the <code>minValue</code> and <code>maxValue</code> fields.</p>"},{"location":"interactions/modals/","title":"Modals","text":""},{"location":"interactions/modals/#overview","title":"Overview","text":"<p>Modals are defined by annotating a method with <code>Modal</code>. The first parameter must always be a <code>ModalEvent</code>.</p> <pre><code>@Modal(\"My Modal\")\npublic void onModal(ModalEvent event, @TextInput(\"Input\") String input) { ... }\n</code></pre>"},{"location":"interactions/modals/#localization-and-placeholders","title":"Localization and Placeholders","text":"<p>To avoid hardcoded values, all string values of an annotation can be replaced by a localization key as supported by the current used Localization System.</p> <p>Furthermore, it's possible to directly use placeholders. For more information on how to use placeholders please visit this page.</p> <p>Also take a look at the general message resolution documentation.</p> <p>Key Example (with Fluava)</p> <pre><code>@Modal(\"my.localization.key\")\npublic void onModal(ModalEvent event, @TextInput(\"Input\") String input) { ... }\n</code></pre> <p>Placeholder Example</p> <pre><code>@Modal(\"{ $modal_name }\")\npublic void onModal(ModalEvent event, @TextInput(\"Input\") String input) { ... }\n</code></pre>"},{"location":"interactions/modals/#unicode-and-application-emojis","title":"Unicode and application emojis","text":"<p>JDA-Commands has built in support for Unicode and application emoji aliases. If you want to use them, just take a look here.</p>"},{"location":"interactions/modals/#text-inputs","title":"Text Inputs","text":"<p>You can add text inputs to a modal by adding String parameters annotated with <code>TextInput</code>. The label and other metadata of the text input is passed to the annotation. </p> <p>Tip</p> <p>Just as for command options, the parameter name will be used for the label by default. However, this requires the  <code>-parameters</code> compiler flag to be enabled. </p> <p>Text Inputs can be configured with the following fields:</p>"},{"location":"interactions/modals/#style","title":"style","text":"<p>Sets the <code>TextInputStyle</code>.  The default value is <code>TextInputStyle#PARAGRAPH</code>.</p> <p>Example</p> <pre><code>@Modal(\"Ban reason\")\npublic void onModal(ModalEvent event, @TextInput(value = \"Reason\", style = TextInputStyle.SHORT) String input) { ... }\n</code></pre>"},{"location":"interactions/modals/#placeholder","title":"placeholder","text":"<p>Sets the placeholder of a text input.</p> <p>Example</p> <pre><code>@Modal(\"Ban reason\")\npublic void onModal(ModalEvent event, @TextInput(value = \"Reason\", placeholder = \"Please give a reason\") String input) { ... }\n</code></pre>"},{"location":"interactions/modals/#defaultvalue","title":"defaultValue","text":"<p>Sets the default value of a text input, which will pre-populate the text input field with the specified String. </p> <p>Example</p> <pre><code>@Modal(\"Ban reason\")\npublic void onModal(ModalEvent event, @TextInput(value = \"Reason\", defaultValue = \"Rule Violation\") String input) { ... }\n</code></pre>"},{"location":"interactions/modals/#minvalue-maxvalue","title":"minValue &amp; maxValue","text":"<p>Sets the minimum and maximum input length of a text input.</p> <p>Example</p> <pre><code>@Modal(\"Ban reason\")\npublic void onModal(ModalEvent event, @TextInput(value = \"Reason\", maxValue = 1000) String input) { ... }\n</code></pre>"},{"location":"interactions/modals/#required","title":"required","text":"<p>Sets whether the text input is required. The default value is <code>true</code>.</p> <p>Example</p> <pre><code>@Modal(\"Ban reason\")\npublic void onModal(ModalEvent event, @TextInput(value = \"Reason\", required = false) String input) { ... }\n</code></pre>"},{"location":"interactions/modals/#replying-with-modals","title":"Replying with Modals","text":"<p>You can reply to <code>CommandEvents</code>  and <code>ComponentEvents</code> with a Modal by calling <code>ModalReplyableEvent#replyModal(String, Entry...)</code> on the event.</p> <p>Example</p> <pre><code>@Command(\"ban\")\npublic void onCommand(CommandEvent event, User target) {\n    event.replyModal(\"onModal\"); //(1)!\n}\n\n@Modal(\"Ban reason\")\npublic void onModal(ModalEvent event, @TextInput(\"Reason\") String input) { ... }\n</code></pre> <ol> <li>We reference the Modal we want to send via the method name.</li> </ol>"},{"location":"interactions/modals/#dynamic-modals","title":"Dynamic Modals","text":"<p>Sometimes you want to modify a Modal dynamically at runtime. You can do so by calling <code>ModalReplyableEvent#replyModal(String, Function)</code></p> <p>Example</p> <pre><code>event.replyModal(\"onModal\", modal -&gt; modal.title(\"Cool Title!\"));\n</code></pre> <p>If you want to, you can also use the native JDA builder:</p> <p>Example</p> <pre><code>event.replyModal(\"onModal\", modal -&gt; modal.modify(jdaBuilder -&gt; jdaBuilder.setTitle(\"Boring Title!\")));\n</code></pre>"},{"location":"interactions/overview/","title":"Overview","text":"<p>Info</p> <p>Please make yourself familiar with our Runtime Concept before you proceed. This is a  centerpiece of JDA-Commands and a requirement for understanding the following parts.</p>"},{"location":"interactions/overview/#structure","title":"Structure","text":"<p>In JDA-Commands you define interactions as methods. These methods must be contained in a class annotated with  <code>Interaction</code>, which is also referred to as the interaction controller. </p> <p>Each method controls one interaction. The interaction data gets defined by annotations and sometimes by the method signature.  JDA-Commands will call the method when the interaction gets executed by a user. </p> <p>Tip</p> <p>It is recommended that you define one conversation per class. By conversation, we mean a logical sequence of interactions, for example a Slash Command that is replied to with a Button followed by a Modal.   </p> <pre><code>@Interaction//(1)!\npublic class GreetCommand {\n\n    @Command(value = \"greet user\", desc = \"Play cookie clicker\")//(2)!\n    public void onGreet(CommandEvent event, @Param(\"The user you want to greet\") User user) {//(3)!\n        event.reply(\"Hello %s\", user.getAsMention());\n    }\n}\n</code></pre> <ol> <li>This marks the <code>GreetCommand</code> class as an interaction controller.</li> <li>This defines the Slash Command and also tells JDA-Commands to call the <code>onGreet</code> method for this command.</li> <li>In that case the method signature also defines part of the interaction.</li> </ol>"},{"location":"interactions/overview/#runtime-scoped-instances","title":"Runtime Scoped Instances","text":"<p>JDA-Commands will create one instance of the interaction controller class per conversation, which is stored in the corresponding Runtime. That way you don't need to worry about the scope of your variables. Even if multiple users execute your interaction simultaneously, they cannot affect the state of other executions. </p> <p>Let's say we have the following code: <pre><code>@Interaction\npublic class CookieClicker {\n\n    private int counter;\n\n    @Command(value = \"cookie clicker\", desc = \"Play cookie clicker\")//(1)!\n    public void onClicker(CommandEvent event) {\n        event.with().components(\"onCookie\").reply(\"You've got { $count } cookie(s)!\", entry(\"count\", counter));//(2)!\n    }\n\n    @Button(value = \"Collect\", emoji = \"\ud83c\udf6a\", style = ButtonStyle.SUCCESS)//(2)!\n    public void onCookie(ComponentEvent event) {\n        event.reply(\"You've got { $count } cookie(s)!\", entry(\"count\", counter++));//(2)!\n    }\n\n}\n</code></pre></p> <ol> <li>This will be a command called <code>/cookie clicker</code></li> <li>This will be a button labeled with <code>Collect \ud83c\udf6a</code> </li> </ol> <p>Let's see what's going on here:</p> <ul> <li> <p>The <code>/cookie clicker</code> command is an entrypoint for starting a new conversation. Everytime the command gets executed JDA will hand over a <code>SlashCommandInteractionEvent</code> to JDA-Commands, which is used to create a new Runtime. </p> </li> <li> <p>This Runtime will then create a new instance of the <code>CookieClicker</code> class. This instance is used to execute the <code>onClicker</code> method.</p> </li> <li> <p>When the <code>Collect \ud83c\udf6a</code> button gets clicked the same Runtime and thus the same instance of the  <code>CookieClicker</code> class will be used to execute the <code>onCookie</code> method.</p> </li> <li> <p>This also means the <code>Collect \ud83c\udf6a</code> button is only usable as long as the Runtime is alive and thus the instance of  the <code>CookieClicker</code> class exists. You can circumvent this by making the <code>Collect \ud83c\udf6a</code> button independent.</p> </li> </ul>"},{"location":"interactions/reply/","title":"Reply Building","text":"<p>Note</p> <p>All event types share the same Reply API. JDA-Commands will only acknowledge the interaction event just before sending the reply. If you need more time, e.g. for doing a database query, you can always manually acknowledge events by calling <code>event#deferReply()</code>.</p>"},{"location":"interactions/reply/#localization-and-placeholders","title":"Localization and Placeholders","text":"<p>To avoid hardcoded values, all string properties of a component/the content of a message can be replaced by a localization key as supported by the current used Localization System.</p> <p>Furthermore, it's possible to directly use placeholders. For more information on how to use placeholders please visit this page.</p> <p>Also take a look at the general message resolution documentation.</p> <p>Example</p> <pre><code>event.with().ephemeral(true).reply(\"my.localizatoin.key\");\n</code></pre>"},{"location":"interactions/reply/#unicode-and-application-emojis","title":"Unicode and application emojis","text":"<p>JDA-Commands has built in support for Unicode and application emoji aliases. If you want to use them, just take a look here.</p>"},{"location":"interactions/reply/#text-messages","title":"Text Messages","text":"<p>The simplest way of sending a reply is using the <code>ReplyableEvent#reply(String, Entry...)</code> method. This will send a non-ephemeral text message. If the event has already been replied to, this method will edit the  original message instead of sending a new one by default.</p> <p>The <code>reply()</code> method also has some useful overloads, you can find a full list here.</p>"},{"location":"interactions/reply/#reply-configuration","title":"Reply Configuration","text":"<p>You can change the default reply behavior by calling <code>ReplyableEvent#with()</code> before sending the reply. This will return a <code>ConfigurableReply</code> object to you, you can use to modify settings:</p> <p>Ephemeral Reply</p> <pre><code>event.with().ephemeral(true).reply(\"Hello World!\");\n</code></pre> <p>When calling <code>ComponentEvent#with()</code> you get a <code>EditableConfigurableReply</code> which allows for even more settings:</p> <ul> <li><code>editReply(boolean)</code>: This will send a new message instead of editing the original one.</li> <li><code>keepComponents(boolean)</code>: This will keep the original components</li> <li><code>keepSelections(boolean)</code>: This will keep the user selections of the original components</li> </ul>"},{"location":"interactions/reply/#action-components","title":"Action Components","text":""},{"location":"interactions/reply/#replying-with-action-components","title":"Replying with Action Components","text":"<p>The <code>ConfigurableReply</code> object is also used to attach components. You reference action components by the name of the method they are defined with, just like we did before with modals.</p> <p>Example</p> <pre><code>@Command(\"greet\")\npublic void onCommand(CommandEvent event) {\n    event.with().components(\"onButton\").reply(\"Hello World!\"); //(1)!\n}\n\n@Button(\"Greet me!\")\npublic void onButton(ButtonEvent event) { \n    event.reply(\"Hello %s\".formatted(event.getUser().getAsMention()));\n}\n</code></pre> <ol> <li>We reference the Button we want to send via the method name.</li> </ol> <p>You can also omit the text message and only send the component by calling <code>reply()</code> with no arguments.</p>"},{"location":"interactions/reply/#action-rows","title":"Action Rows","text":"<p>Every call to <code>components()</code> will create a new action row. If you want more than one action row you need to call <code>components()</code> multiple times.</p> <p>Example</p> <pre><code>event.with().components(\"firstButton\").components(\"secondButton\").reply();\n</code></pre> <p>If you want to add multiple action components to the same action row, just pass the method names to the same <code>components()</code> call.</p> <p>Example</p> <pre><code>event.with().components(\"firstButton\", \"secondButton\").reply();\n</code></pre> <p>Note</p> <p>One action row supports up to 5 buttons but only 1 select menu.</p>"},{"location":"interactions/reply/#enabling-disabling","title":"Enabling &amp; Disabling","text":"<p>By default, all action components are enabled. If you want to attach a disabled action component, you need to wrap it by calling <code>Component#disabled(String, Entry...)</code></p> <p>If you want to add multiple action components to the same action row, with some of them enabled and some disabled, you need to wrap all of them.</p> <p>Example</p> <pre><code>event.with.components(Component.disabled(\"firstButton\"), Component.enabled(\"secondButton\")).reply();\n</code></pre>"},{"location":"interactions/reply/#keeping-components","title":"Keeping Components","text":"<p>When working with components and especially when building menus, e.g. a pagination with buttons, it is often needed to keep the components attached, even when editing the original message multiple times. </p> <p>Normally, Discord would remove any components when sending a message edit, unless they are explicitly reattached.</p> <p>JDA-Commands flips this behavior and will keep your components attached by default. </p> <p>You can disable this by calling <code>keepComponents(false)</code>:</p> <p>Example</p> <pre><code>event.with().keepComponents(false).reply(\"Message edit!\");\n</code></pre> <p>Alternatively you can call <code>ComponentEvent#removeComponents()</code> which will remove all action components attached to a message.</p> <p>Note</p> <p>When using Components V2 calling <code>ComponentEvent#removeComponents()</code> will throw an <code>UnsupportedOperationException</code> because this would result in an empty message.</p> <p>Cookie Clicker Example</p> CodeExecution <pre><code>@Interaction\npublic class CookieClicker {\n\n    private int counter;\n\n    @Command(value = \"cookie clicker\", desc = \"Play cookie clicker\")\n    public void onClicker(CommandEvent event) {\n        event.with().components(\"onCookie\").reply(\"You've got { $count } cookie(s)!\", entry(\"count\", counter));\n    }\n\n    @Button(value = \"Collect\", emoji = \"\ud83c\udf6a\", style = ButtonStyle.SUCCESS)\n    public void onCookie(ComponentEvent event) {\n        event.reply(\"You've got { $count } cookie(s)!\", entry(\"count\", counter++));\n    }\n}\n</code></pre> <p></p>"},{"location":"interactions/reply/#keeping-selections","title":"Keeping Selections","text":"<p>By default, JDA-Commands will also retain the selections of select menus when sending a reply with <code>keepComponents</code> set to <code>true</code>. You can disable this by calling <code>keepSelections(false)</code>:     !!! example     <pre><code>event.with().keepSelections(false).reply(\"Message edit!\");\n</code></pre></p>"},{"location":"interactions/reply/#foreign-components","title":"Foreign Components","text":"<p>You can attach action components that were defined in a different class by using the <code>Component#enabled(Class, String, Entry...)</code> class again. In addition to the method name, you must also pass the class reference in that case.</p> <p>Example</p> <pre><code>event.with()\n    .components(Component.enabled(ButtonHelpers.class, \"onConfirm\"), Component.enabled(ButtonHelpers.class, \"onDeny\"))\n    .reply(\"Are you sure?\");\n</code></pre> <p>The foreign action component will use the original Runtime just like any other action component would. If no  instance of the class the action component is defined in (<code>ButtonHelpers</code> in the example above) exists yet,  the Runtime will create one instance (and store it for potential future method calls). </p>"},{"location":"interactions/reply/#lifetime","title":"Lifetime","text":"<p>As discussed earlier, Runtimes have a limited lifetime. By default, JDA-Commands will close a Runtime after 15 minutes of no activity have passed. </p> <p>Component Lifetime</p> <p>This means all action components belonging to that Runtime will stop working once the Runtime is closed!</p> <p>JDA-Commands will handle this case for you. This error message can be customized.</p> <p></p> <p>If you want to avoid this behavior, you have to reply with action components that are <code>runtime-independent</code>. They will create a new <code>Runtime</code> everytime they are executed. These action components will even work after a full bot restart! If you want them to not be usable anymore you need to remove them on your own.</p> <p>Info</p> <p>Modals cannot be independent because they always need a parent interaction that triggers them!</p> <p>Example</p> <pre><code>event.with().components(Component.independent(\"onButton\")).reply(\"Hello World!\");\n</code></pre>"},{"location":"interactions/reply/#dynamic-components","title":"Dynamic Components","text":"<p>Just like with Modals, you can dynamically modify components too. Use the <code>Component#enabled(Class, String, Entry...)</code> class to access a builder object, which wraps the JDA builder. Alternatively, you can access the native JDA builder by calling <code>#modify</code>.</p> <p>Example</p> <pre><code>event.with().components(Component.button(\"onButton\").label(\"New Label\")).reply(\"Hello World!\");\n\nevent.with().components(Component.stringMenu(\"onMenu\").modify(jdaBuilder -&gt; ...).reply(\"Hello World!\");\n</code></pre>"},{"location":"interactions/reply/#components-v2","title":"Components V2","text":"<p>Note</p> <p>This section assumes that you are already familiar with Components V2. You can find the Discord documentation here. Also, please have a look at JDAs component classes.</p>"},{"location":"interactions/reply/#replying-with-components-v2","title":"Replying with Components V2","text":"<p>You can reply with Components V2 by passing one or more <code>MessageTopLevelComponent</code>s to the  [<code>reply()</code>][[ReplyableEvent#reply(Collection<code>MessageTopLevelComponent</code>, Entry...)]] method.  This will automatically enable the V2 flag. Note that this method is only available either directly at the event class or at the <code>ConfigurableReply</code> stage (accessed by calling <code>with()</code>). </p> <p>Example</p> <pre><code>event.reply(TextDisplay.of(\"Hello World\"));\n\nevent.with().ephemeral(true).reply(TextDisplay.of(\"Hello World\"));\n</code></pre> <p>Note, that you cannot reply with Components V2 after:</p> <ul> <li><code>components(...)</code></li> <li><code>embeds(...)</code></li> <li><code>builder(...)</code></li> </ul> <p>has been called, because adding content, embeds, files, etc. disqualifies the message from being Components V2.</p>"},{"location":"interactions/reply/#action-components_1","title":"Action Components","text":"<p>Components V2 also can have action components. They can either be added to an <code>ActionRow</code> or a <code>SectionAccessoryComponent</code>  as part of a <code>Section</code>. You add them by using the  <code>Component</code> class.</p> <p>Example</p> <pre><code>event.reply(Section.of(Component.button(\"onButton\"), TextDisplay.of(\"Useless Button\")));\n\nevent.reply(ActionRow.of(Component.stringSelect(\"onMenu\"))));\n</code></pre> <p>Enabling and disabling as well as modifying works the same  as explained before.</p>"},{"location":"interactions/reply/#subsequent-replies","title":"Subsequent Replies","text":"<p>Once you've sent a Components V2 message it has to remain Components V2. The Reply Configuration rules also apply to Components V2. </p> <p>Often, you want to keep the original components, but edit some of them. You can do so by calling  <code>reply(ComponentReplacer... replacer)</code>. This method will enforce <code>keepComponents</code> and throw an <code>UnsupportedOperationException</code> if the message isn't Components V2.</p> <p>Example</p> <pre><code>public void onComponent(ComponentEvent event) {\n    event.reply(ComponentReplacer.byUniqueId(1, TextDisplay.of(\"Updated Component\")));\n}\n</code></pre> <p>To make working with the <code>ComponentReplacer</code> easier, you can assign unique ids to components. For action components, which are defined by JDA-Commands, you can either use the component annotation (e.g. <code>@Button</code>) or the dynamic components API.</p>"},{"location":"interactions/reply/#embeds","title":"Embeds","text":"<p>JDA-Commands provides a rich Embed API to make working with Embeds easier. See the Embed Section of this wiki for setup instructions. Once you have your <code>EmbedDataSource</code> configured you can start using Embeds in your replies. </p> <p>Use the <code>ConfigurableReply</code> object, which is accessed by calling  <code>ReplyableEvent#with()</code>,  to attach Embeds to your reply. The easiest way of replying with an Embed is to simply pass the Embeds name:</p> <p>Example</p> <pre><code>event.with().embeds(\"welcome\").reply();\n</code></pre> <p>You can also pass multiple names or call the <code>#embed(...)</code> method multiple times:</p> <p>Example</p> <pre><code>event.with().embeds(\"welcome\", \"goodbye\").reply();\n\nevent.with().embeds(\"welcome\").embeds(\"goodbye\").reply();\n</code></pre> <p>For modifying you can either use the <code>Embed</code> object or use a callback:</p> <p>Example</p> Embed ObjectCallback <pre><code>Embed embed = event.embed(\"welcome\");\nembed.title(\"New title\");\nevent.with().embeds(embed).reply();\n</code></pre> <pre><code>event.with().embeds(\"welcome\", embed -&gt; embed.title(\"New title\")).reply();\n</code></pre> <p>Placeholders can be passed not only to the <code>Embed</code> object, but also directly to the <code>#embed(...)</code> method:</p> <p>Example</p> <pre><code>event.with().embeds(\"welcome\", Entry.entry(\"user\", \"Kaktushose\")).reply();\n</code></pre>"},{"location":"interactions/reply/#replyconfig","title":"ReplyConfig","text":"<p>The <code>ReplyConfig</code> annotation provides a way to modify the default behaviour for the <code>editReply</code>, <code>ephemeral</code> and <code>keepComponents</code> settings.  You can either annotate single methods or entire interaction controllers. </p> <p>ReplyConfig Annotation</p> <pre><code>@Interaction\n@ReplyConfig(ephemeral = true)\npublic class InteractionController {\n\n    @Command(\"example\")\n    @ReplyConfig(editReply = false)\n    public void onCommand(CommandEvent) {...}\n\n}\n</code></pre> <p>Alternatively, you can set a global reply config at the builder:</p> <p>Global ReplyConfig</p> <pre><code>JDACommands.builder(jda, Main.class)\n    .globalReplyConfig(new ReplyConfig(true, false, false))\n    .start();\n</code></pre> <p>JDA-Commands will apply clashing ReplyConfigs in the following hierarchy:</p> <ol> <li><code>with()#...</code> calls </li> <li><code>ReplyConfig</code> method annotation</li> <li><code>ReplyConfig</code> class annotation</li> <li>global <code>ReplyConfig</code></li> </ol>"},{"location":"message/embeds/","title":"Embed API","text":""},{"location":"message/embeds/#embeddatasource","title":"EmbedDataSource","text":"<p>In JDA, you define Embeds by using the <code>EmbedBuilder</code> which eventually gets built into a <code>MessageEmbed</code>. <code>MessageEmbeds</code> can be serialized into (and deserialized from) <code>JSON</code>. </p> <p>Tip</p> <p>For details on the <code>JSON</code> format of Embeds, see the Discord Documentation or use one the various Online Embed Builders.</p> <p>JDA-Commands takes advantage of this and provides the <code>EmbedDataSource</code> interface to load Embeds from a <code>JSON</code> object. It supports the following sources by default:</p> <ul> <li>a raw <code>JSON</code> String</li> <li>a <code>*.json</code> file either located externally or inside the <code>resources</code> folder</li> <li>an <code>InputStream</code></li> <li>JDAs <code>DataObject</code></li> </ul> <p>You can also provide your own sources by implementing the <code>EmbedDataSource</code> interface. </p> <p>The <code>JSON</code> object can contain an arbitrary amount of Embeds as child objects. The name of these child objects must be unique and will be later used to load the respective Embed.</p> <p>Example</p> embeds.json<pre><code>{\n    \"welcome\": {\n        \"title\": \"Hello World\",\n        \"description\": \"This will be an example\"\n    },\n    \"goodbye\": {\n        \"title\": \"Bye World\",\n        \"description\": \"This was an example\"\n    }\n}\n</code></pre> <p>When configuring JDA-Commands, you can then use the <code>EmbedConfig</code> to add one or multiple EmbedDataSources to later load Embeds from at various places.</p> <p>Example</p> <pre><code>JDACommands.builder(jda, Main.class)\n    .embeds(config -&gt; config.sources(EmbedDataSource.file(Path.of(\"embeds.json\")))\n    .start();\n</code></pre> <p>Tip</p> <p>EmbedDataSources can also be loaded from extensions by providing values for [Property#EMBED_SOURCES]</p>"},{"location":"message/embeds/#loading-embeds","title":"Loading Embeds","text":"<p>You can either use the <code>JDACommands</code> or the <code>ReplyableEvent</code> class to load embeds into an object.  </p> <p>Embeds don't get loaded directly into a JDA <code>MessageEmbed</code> or <code>EmbedBuilder</code> object. Instead, JDA-Commands provides a subclass of <code>EmbedBuilder</code>, simply called <code>Embed</code>.  It provides some additional utility, e.g. when dealing with fields, and is also required for the localization and  placeholder feature. </p> <p>Example</p> EventJDACommands <pre><code>@Command(\"example\")\npublic void onCommand(CommandEvent event) {\n    Embed embed = event.embed(\"welcome\");\n    embed.title(\"New title\");\n    MessageEmbed message = embed.build();\n}\n</code></pre> <pre><code>Embed embed = JDACommands.embed(\"welcome\");\nembed.title(\"New title\");\nMessageEmbed message = embed.build();\n</code></pre> <p>Tip</p> <p>The <code>#embed(String)</code> method will throw an <code>IllegalArgumentException</code> if no Embed with the given name was found. Use the  <code>JDACommands#findEmbed(String)</code> method, which returns an Optional, if you cannot ensure that the Embed exists.</p> <p>See the Reply Section of this wiki to learn more about on how to use Embeds for your interaction replies.</p>"},{"location":"message/embeds/#localization","title":"Localization","text":"<p>Just like any other feature of JDA-Commands, Embeds can be localized as well. For the default Localizer implementation,  which uses Fluava, this could look like this:</p> <p>Example</p> embeds.json<pre><code>{\n    \"welcome\": {\n        \"title\": \"welcome-title\", // will load from the \"default\" bundle if no @Bundle annotation is present\n        \"description\": \"my_bundle#welcome-description\" // will load from the \"my_bundle\" bundle\n    }\n}\n</code></pre> <p>Use <code>Embed#locale(Locale)</code> to set the locale the Embed should be localized with. When replying to interactions, this is done automatically by using <code>GenericInteractionCreateEvent#getUserLocale()</code> to retrieve the user locale. The Embed will be localized once <code>Embed#build()</code> is called. </p> <p>See the Localization Section of this wiki for details.</p>"},{"location":"message/embeds/#placeholders-and-emojis-message-resolution","title":"Placeholders and emojis (message resolution)","text":"<p>You can add placeholders to your Embeds just like in many other places in this framework. JDA-Commands will resolve the content of embeds according to the documentation here.</p> <p>Example</p> embeds.json<pre><code>{\n    \"welcome\": {\n        \"title\": \"Hello\", \n        \"description\": \"Greetings { $user }\" \n    }\n}\n</code></pre> <p>You can then use the <code>Embed#placeholders(Entry...)</code> method to insert the placeholder values.</p> <p>Example</p> <pre><code>Embed embed = ...;\nembed.placeholders(Entry.entry(\"user\", \"Kaktushose\"));\n</code></pre> <p>You can of course also use your placeholders regularly inside the localization files. </p>"},{"location":"message/embeds/#global-placeholders","title":"Global Placeholders","text":"<p>A special feature of the Embed API is that you can define global placeholders for your Embeds using the <code>EmbedConfig</code>.</p> <p>Example</p> <pre><code>JDACommands.builder(jda, Main.class)\n    .embeds(config -&gt; config.placeholders(Entry.entry(\"bot-name\", \"JDA-Commands Bot\")))\n    .start();\n</code></pre> <p>Global placeholders can be used anywhere inside your Embeds.</p>"},{"location":"message/emojis/","title":"Emojis","text":"<p>JDA-Commands supports using emoji aliases for Unicode and application emojis in all places where localization is done implicitly.</p> <p>This is done after placeholder resolution and localization took place.</p> <p>JDA-Commands emoji aliases are very similar to the ones used by the discord client.  They follow the same format <code>:emoji_name:</code> for both Unicode and application emojis.  Setting the skintone like <code>:emoji_name::skin-tone-5:</code> is supported too.</p> <p>Since emoji aliases are resolved after localization takes place, you can also use them in your localization messages regardless of the used <code>Localizer</code>.</p> Escaping the colon <p>Normally it shouldn't be necessary to escape the colons in messages (that shouldn't be an emoji alias), but in case any troubles occur you can just prefix it with <code>\\</code> (in Java <code>\\\\</code>) to escape it.</p>"},{"location":"message/emojis/#unicode-emojis","title":"Unicode Emojis","text":"<p>If you want to avoid annoying encoding issues with hardcoded Unicode emojis, you can just use the known Discord client aliases in JDA-Commands too.</p> <p>Unicode Emoji</p> <pre><code>@Command(\"example\")\npublic void onCommand(CommandEvent event) {\n    event.reply(\"Hi :smiley:\");\n}\n</code></pre> <p>This will reply with <code>Hi \ud83d\ude00</code> to the user.</p> <p>Note</p> <p>We're using the amazing JEmoji library to resolve Unicode Discord aliases. If something doesn't feel right with the used aliases/emojis please reach out to them here.</p>"},{"location":"message/emojis/#application-emojis","title":"Application Emojis","text":"<p>Application emojis can be used exactly the same as Unicode emojis in messages with the custom emoji name as the alias. If an application emoji is called the same as a Unicode emoji alias, the application emoji takes precedence.</p> <p>Warning</p> <p>JDA-Commands fetches and caches all application emojis upon startup. Therefore, JDA-Commands has to be restarted if changes are made to them.</p> <p>Application Emoji</p> <pre><code>@Command(\"example\")\npublic void onCommand(CommandEvent event) {\n    event.reply(\"Hi :my_custom_emoji:\");\n}\n</code></pre> <p>This will reply <code>Hi &lt;you custom emoji here&gt;</code> to the user.</p>"},{"location":"message/emojis/#automatic-application-emoji-registration","title":"Automatic Application Emoji Registration","text":"<p>Adding application emojis manually in the webinterface is an annoying task, but for your luck JDA-Commands comes with tools to register your emojis automatically upon startup. Please note that we cannot unregister application emojis due to api limits. </p> <p>Similar to how ClassFinders work, JDA-Commands uses EmojiSources to load your application emojis from different places. Per default there are 3 types of <code>EmojiSources</code>:</p> <ul> <li><code>EmojiSource#reflective(String...)</code>   that searches the classpath (resources) for files in the stated directories/packages.</li> <li><code>EmojiSource#fromUrl(String, URL)</code>   that loads an emoji with the given name from this URL</li> <li><code>EmojiSource#fromIcon(String, Icon)</code>   that just works as an interop to JDAs own emoji api</li> </ul> <p>If no EmojiSources are set by the user in the JDA-Commands Builder, the resource directory <code>emojis</code> will be searched for application emojis per default.</p> <p>Example</p> <p>If your resource directory looks like: <pre><code>src/\n\u251c\u2500 main/\n\u2502  \u251c\u2500 resources/\n\u2502  \u2502  \u251c\u2500 emojis/\n\u2502  \u2502  \u2502  \u251c\u2500 laughing.gif\n\u2502  \u2502  \u2502  \u251c\u2500 hola.png\n</code></pre> then JDA-Commands will register the application emojis \"laughing\" and \"hola\" upon startup.</p> <p>If you want to use custom EmojiSources just take a look here.</p>"},{"location":"message/localization/","title":"Localization","text":"<p>JDA-Commands provides the <code>I18n</code> class, which is used as the main entrypoint for localization. This class can be used by users of the framework to localize their messages.</p>"},{"location":"message/localization/#localization-messages","title":"Localization Messages","text":"<p>Localization messages are identified by their corresponding key. A key can be freely chosen but might be limited by the restrictions of the used <code>Localizer</code> implementation.</p> <p>If a certain message for a key isn't found, the key is returned as the messages value.</p>"},{"location":"message/localization/#the-dollar-character","title":"The Dollar ($) Character","text":"<p>The dollar (<code>$</code>) is a reserved character for bundle name separation.</p> <p>In practically all cases this doesn't really bother you, because there are only two edge cases where the dollar has to be escaped.</p> Edge Cases <ul> <li>Your message key contains <code>$</code> and no bundle is explicitly stated, e.g. <code>key.with$.in.it</code> (the default bundle should be used here)</li> <li>The string is a \"raw\" message containing <code>$</code>, that happens to have its prior <code>$</code> part to match a bundle name and its after <code>$</code> part to match a message key, e.g.:<ol> <li>you have a bundle called <code>my_bundle</code></li> <li>you have a message key called <code>my-key</code> in that bundle</li> <li>and you want to print the message <code>my_bundle$my-key</code> to the user (not the message stored under \"my-key\" in the bundle \"my_bundle\")</li> </ol> </li> </ul> <p>In these cases just prefix your whole message with a <code>$</code>, e.g. <code>$my_bundle$my-key</code> or <code>$key.with$.in.it</code>. Now the bundle will be treated as not stated explicitly and the dollar sign will be preserved.</p>"},{"location":"message/localization/#implicit-localization","title":"Implicit Localization","text":"<p>Due to the implicit resolution of messages, localization is also done in many common places automatically for you. Furthermore, the localization of Slash Commands  is supported through JDAs <code>LocalizationFunction</code>.</p> <p>JDA-Commands will first try to find a localization message based on the provided String (as the key) and the users locale retrieved by <code>GenericInteractionCreateEvent#getUserLocale()</code> and if not found, will use the String directly as the content.</p> <p>Warning</p> <p>Localization of <code>MessageCreateData</code> is not supported implicitly. To localize such messages you have to manually use )&gt;. <p>Example</p> <p><pre><code>@Bundle(\"component\")\n@Interaction\npublic class ComponentTest {\n\n    @Command(\"say hi\")\n    public void onCommand(CommandEvent event) {\n        event.reply(\"command-reply\");\n    }\n\n}\n</code></pre> In this example, the bundle <code>component</code> will be searched for the key <code>command-reply</code>.</p>"},{"location":"message/localization/#placeholders","title":"Placeholders","text":"<p>Your localization messages can also contain placeholders. To learn more about how to use placeholders take a look here.</p> <p>Example with Fluava</p> <pre><code>import static io.github.kaktushose.jdac.message.placeholder.Entry.entry;\n\n@Interaction\npublic class ComponentTest {\n\n    @Command(\"say hi\")\n    public void onCommand(CommandEvent event) {\n        event.with()\n                .components(Component.button(\"onButton\", entry(\"name\", event.getUser().getName())))\n                .reply();\n    }\n\n    @Button(\"button_name\")\n    public void onButton(ComponentEvent event) {\n        ...\n    }\n\n}\n</code></pre> default_en.ftl<pre><code>button_name = Hello { $name }\n</code></pre>"},{"location":"message/localization/#bundles","title":"Bundles","text":"<p>Localization bundles are a known concept from Javas <code>ResourceBundle</code>. JDA-Commands supports different bundles of localization files by adding them to the localization key or using the <code>Bundle</code> annotation.</p> <p>The Dollar Sign ($)</p> <p>Please note that the character <code>$</code> is forbidden in bundle names. Additionally, the bundle name <code>jdac</code>is reserved, for more information visit this section. </p>"},{"location":"message/localization/#via-key","title":"Via Key","text":"<p>To state which bundle to use the direct way is to include it in the key following the format <code>bundle$key</code>. For example a message with key <code>user$not-found</code> will be searched for in the bundle <code>user</code> and the key <code>not-found</code>.</p>"},{"location":"message/localization/#via-annotation","title":"Via Annotation","text":"<p>If no bundle is specified, JDA-Commands will traverse the stack (the called methods) and search for the nearest <code>Bundle</code> annotation with following order:</p> <ol> <li>Method that called  <li>Other called methods in the same class</li> <li>This methods class</li> <li>The class' packages <code>package-info.java</code> file</li> <p>If no annotation is found, the previous method (in another class) is searched with the same pattern up to the class at the very beginning.</p> Detailed Example <p>A.java<pre><code>package my.app;\n\nclass A {\n    void aOne() {\n        i18n.localize(Locale.GERMAN, \"fail\", Map.of());\n    }\n\n    void aTwo() {\n        aOne();\n    }\n}\n</code></pre> B.java<pre><code>package my.app.other;\n\n@Bundle(\"class_bundle\")\nclass B {\n    A another = new A();\n\n    void bOne() {\n        a.aOne();\n    }\n\n    @Bundle(\"method_bundle\")\n    void bTwo() {\n        bOne();\n    }\n}\n</code></pre> package-info.java<pre><code>@Bundle(\"package_bundle\")\npackage my.app;\n</code></pre></p> <p>The order in which the bundle name is searched for is following:</p> <ol> <li>method <code>A$aOne()</code></li> <li>method <code>A$aTwo()</code></li> <li>class <code>A</code></li> <li><code>package-info.java</code> of package <code>my.app</code></li> <li>method <code>B$bOne()</code></li> <li>method <code>B$bTwo()</code></li> </ol> <p>The found bundle would be <code>package_bundle</code>. If <code>I18n#localize(Locale, String, Entry...)</code> would be called in, for example, <code>B$bTwo</code> the bundle would be <code>method_bundle</code>.</p>"},{"location":"message/localization/#default-bundle","title":"Default Bundle","text":"<p>If no bundle is found with the above techniques, a bundle called <code>default</code> will be used.</p>"},{"location":"message/localization/#localization-of-default-messages","title":"Localization of Default Messages","text":"<p>JDA-Commands sometimes presents error messages or strings to the user of the Discord bot, that aren't defined by the developer per default. For most cases the default values for these messages shipped with JDA-Commands will be sufficient, but some developers might like to  localize them. </p> <p>For this task the reserved bundle <code>jdac</code> was defined, allowing the customization of following messages (localization keys):</p> <ul> <li><code>member-missing-permission</code>: if a <code>Member</code> doesn't have the permission required by <code>Perm</code></li> <li><code>member-has-unallowed-permission</code>: if a <code>Member</code> has the permission forbidden by <code>NotPerm</code></li> <li><code>member-required-got-user</code>: if a <code>Member</code> is required, but only a user was given as a slash command option input</li> <li><code>no-description</code>: if no description was stated for a slash command or slash command option</li> </ul> <p>Example</p> jdac_de.ftl<pre><code>member-missing-permission = Du hast nicht die ben\u00f6tigte Berechtigung!\nno-description = Keine Beschreibung angegeben!\n</code></pre>"},{"location":"message/localization/#localizationfunction-jda-slash-command-localization","title":"LocalizationFunction (JDA) / Slash Command Localization","text":"<p>JDA uses the <code>LocalizationFunction</code> for localizing slash commands. We implement this interface based on our <code>I18n</code> class as described above.</p> <p>If you want to disable slash commands localization just call <code>JDACBuilder#localizeCommands(false)</code>.</p> <p>See the JDA Docs for details.</p>"},{"location":"message/localization/#default-implementation","title":"Default Implementation","text":"<p>By default, JDA-Commands supports localization with help of the Fluava library, a Project Fluent implementation for Java. You can provide an own instance of the Fluava class by calling the appropriate builder method.</p> <pre><code>Fluava myFluava = Fluava.create(Locale.GERMAN);\n\nJDACommands.builder(jda, Main.class)\n    .localizer(new FluavaLocalizer(myFluava))\n    .start();\n</code></pre> <p>Fallback Bundle</p> <p>To change the fallback bundle you have to pass it to the <code>Fluava#create(Locale)</code> method. In the above example the fallback locale is German. The default fallback locale of JDA-Commands is English.</p> <p>Note</p> <p>JDA-Commands will set <code>FluavaBuilder.FunctionConfig#fallbackToString(boolean)</code> to <code>true</code> when using <code>FluavaLocalizer</code>, thus always enabling falling back to <code>Object#toString()</code> if necessary.</p>"},{"location":"message/localization/#localization-keys","title":"Localization Keys","text":"<p>Since <code>Project Fluent</code> doesn't support dots (<code>.</code>) in localization keys, the Fluava  integration will change all dots to dashes (<code>-</code>). For example, <code>my.key</code> will become <code>my-key</code>. This change also effects  all JDA Slash Command localization keys.</p>"},{"location":"message/localization/#localization-files","title":"Localization Files","text":"<p><code>Fluava</code> supports the loading and discovery of bundles on the classpath  (resource directory) similar to Javas <code>ResourceBundle</code> but with a slightly more flexible structure.</p> <p>The classpath will be lazily searched for a fluent file given a specific locale with the following order:</p> <ol> <li><code>BASE_LANGUAGE_COUNTRY_VARIANT.ftl</code></li> <li><code>BASE/LANGUAGE_COUNTRY_VARIANT.ftl</code></li> <li><code>BASE_LANGUAGE_COUNTRY.ftl</code></li> <li><code>BASE/LANGUAGE_COUNTRY.ftl</code></li> <li><code>BASE_LANGUAGE.ftl</code></li> <li><code>BASE/LANGUAGE.ftl</code></li> </ol> <p>If a key isn't found in any of the above files, the same procedure will be done for the given \"fallback\" locale.</p> <p>A resource folder structure could for example look like this:</p> <pre><code>src/\n\u251c\u2500 main/\n\u2502  \u251c\u2500 resources/\n\u2502  \u2502  \u251c\u2500 component/\n\u2502  \u2502  \u2502  \u251c\u2500 de.ftl\n\u2502  \u2502  \u2502  \u251c\u2500 en.ftl\n\u2502  \u2502  \u251c\u2500 default_de.ftl\n\u2502  \u2502  \u251c\u2500 default_en.ftl\n</code></pre> <p>Such a structure has the two bundles <code>component</code> and <code>default</code> and a locale specific file for German and English for each bundle.</p>"},{"location":"message/overview/","title":"Messages","text":"<p>Messages are a central part of JDA-Commands, they include content send to the user via the reply API, strings used in framework annotations and modals and much more.</p> <p>To provide the best user experience possible, JDA-Commands comes included with localization, support for placeholders and Unicode and app emojis. In many places in the framework, these feature are applied implicitly.</p>"},{"location":"message/overview/#resolution","title":"Resolution","text":"<p>The features listed above are all pipelined together with help of the <code>MessageResolver</code>.</p> <p>They are applied to the string provided by the user in following order:</p> <ol> <li>resolution of placeholders</li> <li>localization</li> <li>resolution of emoji aliases</li> </ol> <p>The resulting string is then send to Discord or returned to the user.</p>"},{"location":"message/overview/#usage","title":"Usage","text":"<p>Instead of manually using the <code>MessageResolver</code> class, JDA-Commands allows for implicit resolution of messages in many common please. These include:</p> <ul> <li>Component API including the corresponding annotations like <code>Button</code>,   <code>Modal</code> etc.</li> <li>Embed API </li> <li>Reply API, for example the string content of a message <code>ReplyableEvent#reply(String, Entry...)</code></li> </ul> <p>If you are using localization, please take a look at implicit localization.</p> <p>Warning</p> <p>Message resolution of content in <code>MessageCreateData</code> is not supported implicitly. You have to use <code>MessageResolver</code> to resolve such messages.</p>"},{"location":"message/overview/#adding-custom-string-resolvers","title":"Adding custom String Resolvers","text":"<p>Sometimes it's necessary to introduce custom resolution logic. JDA-Commands provides <code>Property#STRING_RESOLVER</code> (configurable by <code>JDACBuilder#stringResolver(Resolver...)</code>) allowing the user to add own implementations of  <code>Resolver&lt;String&gt;</code>.</p> <p>Each <code>Resolver</code> has a priority affecting the order in which all registered String Resolvers are applied by <code>MessageResolver</code>. A lower priority is applied first (e.g. <code>I18n</code> runs after <code>PlaceholderResolver</code>).</p> <p>The default Resolvers have the following priorities:</p> <ul> <li><code>PlaceholderResolver</code> = 1000</li> <li><code>I18n</code> = 2000</li> <li><code>EmojiResolver</code> = 3000</li> </ul>"},{"location":"message/overview/#example","title":"Example","text":"<pre><code>public class URLResolver implements Resolver&lt;String&gt; {\n\n    public String resolve(String msg, Locale locale, Map&lt;String, @Nullable Object&gt; placeholders) {\n        return msg.replace(\"JDAC_GH\", \"https://github.com/Kaktushose/jda-commands\");\n    }\n\n    public int priority() {\n        return 4000; // should run after all built in resolvers\n    }\n}\n</code></pre>"},{"location":"message/placeholder/","title":"Placeholders","text":""},{"location":"message/placeholder/#format","title":"Format","text":"<p>The overall placeholder format is <code>{ $your_placeholder }</code>, with following properties:</p> <ul> <li>the leading <code>$</code> is optional</li> <li>whitespace, newlines, <code>{</code> and <code>$</code> are forbidden inside the reference name</li> <li>trailing and leading whitespace or newline of the reference name is trimmed (see <code>String#trim()</code>).</li> <li>to escape the <code>{</code> character just prefix it with <code>\\\\</code> (backslashes can be used unescaped in the rest of the string)</li> </ul> <p>Valid Placeholders</p> <ul> <li><code>{ $your_placeholder }</code></li> <li><code>{ your_placeholder }</code></li> <li><code>{ \\n your_placeholder \\n}</code></li> </ul> <p>Invalid Placeholders</p> <ul> <li><code>{ white space }</code></li> <li><code>{ dollar$sign }</code></li> <li><code>{ bra{cket}</code> (will result in <code>{ bra}</code> as plain text and <code>{cket}</code> as placeholder)</li> <li><code>{ new \\n line }</code> (meant is new line in the middle of the reference name)</li> </ul> <p>Invalid placeholders will just be treated as literal text.</p> Escaping the opening bracket <p>To escape the opening bracket <code>{</code> just prefix it with <code>\\</code>, like <code>My escaped placeholder \\{ this_is_text }</code>.</p>"},{"location":"message/placeholder/#providing-values","title":"Providing Values","text":"<p>JDA-Commands provides a way to set placeholder values by using the <code>Entry</code> class.</p> <p>Often you will find a vararg of this class at the end of a method parameters list. By adding entries there (preferably by using <code>Entry#entry(String, Object)</code> as a static import) it's possible for you to define placeholders for a given scope.</p> <p>Example Usage</p> <pre><code>event.reply(\"Hello { $user }!\", Entry.entry(\"user\", event.getUser().getAsMention()));\n</code></pre>"},{"location":"message/placeholder/#string-representation","title":"String Representation","text":"<p>To get a variables string representation, JDA-Commands will </p> <ol> <li>call <code>Proteus#convert(S, Type, Type)</code> trying to convert the value to <code>Type.of(String.class)</code></li> <li>if not successful, just call <code>Object#toString()</code></li> </ol> <p>If a variable couldn't be found, <code>null</code> will be inserted.</p>"},{"location":"middlewares/overview/","title":"Middlewares","text":"<p>Middlewares run just before an interaction event gets dispatched. They are used to perform additional checks or add more  info the <code>InvocationContext</code>. Middlewares are intended to provide a flexible system for extending the execution chain.</p> <p>They are executed based on their <code>Priority</code> in the following order:</p> <ol> <li><code>PERMISSIONS</code>: Middlewares with this priority will always be executed first</li> <li><code>HIGH</code>: Highest priority for custom implementations, will be executed right after internal middlewares</li> <li><code>NORMAL</code>: Default priority</li> <li><code>LOW</code>: Lowest priority, will be executed at the end</li> </ol> <p>If one middleware fails, the entire interaction execution gets immediately aborted and no more middlewares will be executed. </p>"},{"location":"middlewares/overview/#default-middlewares","title":"Default Middlewares","text":"<p>JDA-Commands uses its own Middleware API internally to implement some features. All these features can either be  extended or replaced by the user. You can either register your own implementations at the respective builder method or use the <code>Implementation</code> annotation.</p> <p>Note</p> <p>Using the <code>Implementation</code> annotation requires the guice integration (shipped by default). You can read more about it here.</p> <p>Middlewares provided by JDA-Commands include:</p> <ul> <li>Type Adapters</li> <li>Parameter Validation</li> <li>Permissions System</li> </ul>"},{"location":"middlewares/overview/#writing-own-middlewares","title":"Writing own Middlewares","text":"<p>You can write your own middlewares by implementing the <code>Middleware</code> interface. You can cancel an execution by calling <code>InvocationContext#cancel(MessageCreateData)</code>.</p> <p>Example</p> <pre><code>public class LoggingMiddleware implements Middleware {\n\n    public void accept(InvocationContext&lt;?&gt; context) {\n        Logger.log(context.event());\n    }\n\n}\n</code></pre> <p>Then, either register your Middleware at the builder: <pre><code>JDACommands.builder(jda, Main.class)\n    .middleware(Priority.NORMAL, new LoggingMiddleware());\n    .start();\n</code></pre></p> <p>or use the <code>Implementation</code> annotation: <pre><code>@Implementation.Middleware(priority = Priority.NORMAL)\npublic class LoggingMiddleware implements Middleware {...}\n</code></pre></p>"},{"location":"middlewares/overview/#run-only-for-certain-interaction-controllers","title":"Run only for certain interaction controllers","text":"<p>If you want your Middleware to only run for certain interaction controllers, just implement <code>Middleware#runFor()</code> returning the classes of the interaction controllers for which the middleware should run.</p> <p>Run only for HelloController</p> <pre><code>@Middleware(priority = Priority.NORMAL)\npublic class CustomMiddleware implements Middleware {\n\n    private static final Logger log = LoggerFactory.getLogger(CustomMiddleware.class);\n\n    @Override\n    public void accept(InvocationContext&lt;?&gt; context) {\n        log.info(\"run custom middleware\");\n    }\n\n    @Override\n    public Collection&lt;Class&lt;?&gt;&gt; runFor() {\n        return List.of(HelloController.class);\n    }\n}\n</code></pre>"},{"location":"middlewares/permissions/","title":"Permissions","text":"<p>When it comes to permissions there are essentially two options:</p> <ol> <li> <p>Use the <code>default permissions</code> of a slash command. This defines a set of  permissions of who can use a command by default. This will perform a Discord client side check. </p> </li> <li> <p>Use the permissions system of JDA-Commands described below. This will perform a bot side permissions check guild admins have no influence on.</p> </li> </ol> <p>Danger</p> <p>Guild admins can modify the <code>default permissions</code> of a slash command at any time!  If you want to enforce permissions  or secure a critical command further you should use the permissions system of JDA-Commands.</p>"},{"location":"middlewares/permissions/#adding-permissions-to-an-interaction","title":"Adding Permissions to an Interaction","text":"<p>Use the <code>Permissions</code> annotation to add permissions to an interaction. This isn't limited to slash commands, but can be any type of interaction. </p> <p>The <code>Permissions</code> annotation takes an arbitrary amount of Strings as input. Each String defines a <code>permission</code> that must be present. By default, you can pass Discord Permissions, like <code>BAN_MEMBERS</code>. JDA-Commands will then check if the executor has the respective Discord Permission before executing the interaction. </p> <p>Example</p> <pre><code>@Permissions(\"BAN_MEMBERS\")\n@Command(\"moderation ban\")\npublic void onBan(CommandEvent event, Member target) {...}\n</code></pre> <p>Instead of annotating individual interaction methods, you can also annotate the interaction controller class. Class  annotation permissions and method annotation permissions will be combined. </p> <p>Example</p> <pre><code>@Permissions(\"ADMINISTRATOR\")\npublic class AdminCommands {...}\n</code></pre>"},{"location":"middlewares/permissions/#error-message","title":"Error Message","text":"<p>If a user is lacking permissions, JDA-Commands will send an error message:</p> <p></p> <p>You can customize this error message, find more about it here.</p>"},{"location":"middlewares/permissions/#own-permissions","title":"Own Permissions","text":"<p>You can also set up your own permission system, which goes beyond the usage of Discord Permissions. Since you only pass Strings, you have a lot of freedom in the design. Common design choices are:</p> <ul> <li>Domain based system, e.g. <code>guild.mod.kick</code>, <code>guild.mod.ban</code>, etc. also allowing for wildcards like <code>guild.mod.*</code></li> <li>Role based system, e.g. having a <code>USER</code>, <code>MODERATOR</code>, <code>ADMIN</code>, etc. role</li> </ul> <p>For our example, let's go with a role based system:</p> <p>Example</p> <pre><code>@Permissions({\"MODERATOR\", \"ADMIN\"})\n@Command(\"moderation ban\")\npublic void onBan(CommandEvent event, Member target) {...}\n</code></pre> <p>The default <code>PermissionsProvider</code> implementation will always fail, because both <code>MODERATOR</code> and <code>ADMIN</code> are invalid, we have to provide our own implementation. </p>"},{"location":"middlewares/permissions/#permissionsprovider-implementation","title":"PermissionsProvider Implementation","text":"<p>The <code>PermissionsProvider</code> has two almost identical <code>hasPermissions(...)</code> methods.</p> <p>The first one gives you an <code>User</code> object, the second one a  <code>Member</code> object. Therefore, the first method is for interactions that are not executed on a guild (e.g. DMs) and the  second method is for interactions that take place on a guild. Both methods also give you access to the  <code>InvocationContext</code>.</p> <p>This distinction does not necessarily have to be relevant. In most cases, the member method can simply call the user method.</p> What's the difference between a Member and a User? <p>Discord differentiates between <code>Users</code> and <code>Members</code>, whereby a <code>User</code> represents a global Discord user, and a  <code>Member</code> represents a Discord user on a specific guild.</p> <p>Example</p> <pre><code>public class RolePermissionsProvider implements PermissionsProvider {\n\n    private final Collection&lt;Long&gt; admins = List.of(1234567890L);\n    private final Collection&lt;Long&gt; moderators = List.of(1234567890L, 987654321L); //(1)!\n\n    @Override\n    public boolean hasPermission(User user, InvocationContext&lt;?&gt; context) {\n        boolean hasPermissions = true; //(2)!\n\n        for (String permission : context.definition().permissions()) {\n            switch (permission) {\n                case \"ADMIN\" -&gt; hasPermissions = admins.contains(user.getIdLong());\n                case \"MODERATOR\" -&gt; hasPermissions = moderators.contains(user.getIdLong());\n                default -&gt; System.out.println(\"Unknown permission: \" + permission);\n            }\n        }\n\n        return hasPermissions;\n    }\n\n    public boolean hasPermission(@NotNull User user, InvocationContext&lt;?&gt; context) {\n        return hasPermission(member.getUser());\n    }\n}\n</code></pre> <ol> <li>This is a very basic example. In a real world application, you should best use a database for this.</li> <li>This has to be <code>true</code>, so that interactions which don't have any permissions defined, don't fail. </li> </ol> <p>Lastly, we have to register our <code>RolePermissionsProvider</code>.</p> <p>Example</p> <code>@Implementation</code> RegistrationBuilder Registration <pre><code>@Implementation\npublic class RolePermissionsProvider implements PermissionsProvider {\n    ...\n}\n</code></pre> <pre><code>JDACommands.builder(jda, Main.class)\n    .permissionsProvider(new RolePermissionsProvider());\n    .start();\n</code></pre>"},{"location":"middlewares/typeadapter/","title":"Type Adapters","text":"<p>TypeAdapters are a part of the execution chain. They are used to adapt the input of a slash command to the correct type needed to invoke the method.</p>"},{"location":"middlewares/typeadapter/#default-type-adapters","title":"Default Type Adapters","text":"<p>JDA-Commands uses Proteus for its type adapting system. Proteus supports all widening and narrowing primitive conversions as defined by the Java Language Specification. Additionally, JDA-Commands has implemented default type adapters for JDAs <code>GuildChannel</code> and its subtypes.</p> <p>Thus, you can add all primitive types and their respective wrapper types as well as any underlying type of the  <code>OptionType</code> enum as a parameter to your slash command methods. See Command Options for details.</p>"},{"location":"middlewares/typeadapter/#writing-own-type-adapters","title":"Writing Own Type Adapters","text":"<p>As mentioned above, JDA-Commands uses Proteus under the hood for type adapting. The <code>TypeAdapter</code> interface is simply a subtype of Proteus' <code>Mapper.UniMapper</code> The following example only covers the registration part for JDA-Commands. Please refer to the <code>documentation</code> of Proteus for implementation details. </p> <p>Example</p> CommandType Adapter (<code>@Implementation</code> Registration)Type Adapter (Builder Registration) <pre><code>@Command(\"example\")\npublic void onCommand(CommandEvent event, UserProfile profile) {\n    ...\n}\n</code></pre> <pre><code>@Implementation.TypeAdapter(source = String.class, target = UserProfile.class)\npublic class UserProfileTypeAdapter implements TypeAdapter&lt;String, UserProfile&gt; {\n\n    public MappingResult&lt;UserProfile&gt; from(String source, MappingContext&lt;String, UserProfile&gt; context) {\n        return MappingResult.lossless(new UserProfile(source));\n    }\n\n}\n</code></pre> <p><pre><code>public class UserProfileTypeAdapter implements TypeAdapter&lt;String, UserProfile&gt; {\n\n    public MappingResult&lt;CustomType&gt; from(String source, MappingContext&lt;String, UserProfile&gt; context) {\n        return MappingResult.lossless(new UserProfile(source));\n    }\n\n}\n</code></pre> <pre><code>JDACommands.builder(jda, Main.class)\n    .adapter(String.class, UserProfile.class, new UserProfileTypeAdapter());\n    .start();\n</code></pre></p> <p>Tip</p> <p>If your type adapter is simple enough, you could also just use lambda expressions:  <pre><code>JDACommands.builder(jda, Main.class)\n    .adapter(String.class, UserProfile.class, (source, _) -&gt; MappingResult.lossless(new UserProfile(source)));\n    .start();\n</code></pre></p> <p>Your own types will be mapped to <code>OptionType.STRING</code> by default. You can override this mapping by using the <code>Param</code> annotation.</p> <p>Example</p> <pre><code>@Command(\"example\")\npublic void onCommand(CommandEvent event, @Param(type = OptionType.USER) UserProfile profile) {\n    ...\n}\n</code></pre> <p>For our example this would also mean that we would need to update the <code>UserProfileTypeAdapter</code> to use <code>User</code> instead of <code>String</code> as its source type. </p>"},{"location":"middlewares/typeadapter/#error-messages","title":"Error Messages","text":"<p>If the type adapting fails an error message will be sent to the user:</p> <p></p> <p>You can customize this error message, find more about it here.</p>"},{"location":"middlewares/validator/","title":"Validators","text":"<p>Command Options of a Slash Command can have constraints. You can add constraints by annotating the method parameter with the respective annotation. </p>"},{"location":"middlewares/validator/#default-validators","title":"Default Validators","text":"<p>JDA-Commands comes with the following default constraints:</p> <ul> <li><code>Perm</code>:   The user or member that have the specified discord permission.</li> <li><code>NotPerm</code>:   The user or member that doesn't have the specified discord permission.</li> </ul> <p>Example</p> <pre><code>@Command(\"ban\")\npublic void onBan(CommandEvent event, @NotPerm(Permission.ADMINISTRATOR) Member target) {...}\n</code></pre> <p>An error message is sent, if a parameter constraint fails:</p> <p></p> <p>You can customize this error message, find more about it here.</p> <p>The fail messages of these two default constraints can be localized with the localization keys  <code>validator.noperm.fail</code> or <code>validator.perm.fail</code> respectively. </p>"},{"location":"middlewares/validator/#writing-own-validators","title":"Writing own Validators","text":""},{"location":"middlewares/validator/#1-creating-the-annotation","title":"1. Creating the Annotation","text":"<p>First, you need to create an annotation type for your validator. Your annotation must meet the following conditions:</p> <ul> <li> <code>@Target</code> must be <code>ElementType.PARAMETER</code></li> <li> <code>RetentionPolicy</code> must be <code>RUNTIME</code></li> <li> Must be annotated with <code>Constraint</code> defining the valid types for this annotation. </li> </ul> <p>Example</p> <pre><code>@Target(ElementType.PARAMETER)\n@Retention(RetentionPolicy.RUNTIME)\n@Constraint(String.class)\npublic @interface MaxString {\n    int value();\n}\n</code></pre>"},{"location":"middlewares/validator/#2-creating-the-validator","title":"2. Creating the Validator","text":"<p>Secondly, you must create the actual validator by implementing the <code>Validator</code> interface. </p> <p>The <code>Validator#apply(T, A, Validator.Context)</code> method will give you the argument (command option) as well as the annotation object.  If the constraint should fail, you must call <code>Validator.Context#fail(String, Entry...)</code></p> <p>Example</p> <pre><code>public class MaxStringLengthValidator implements Validator&lt;String, MaxString&gt; {\n\n    public boolean apply(String argument, MaxString annotation, Context context) {\n        if (argument.length() &lt; maxString.value()) {\n            context.fail(\"The given String is too long\");\n        }\n    }\n}\n</code></pre>"},{"location":"middlewares/validator/#3-registration","title":"3. Registration","text":"<p>Lastly, you have to register your new validator.</p> <p>Example</p> Builder Registration<code>@Implementation</code> Registration <pre><code>JDACommands.builder(jda, Main.class)\n    .validator(MaxString.class, new MaxStringLengthValidator());\n    .start();\n</code></pre> <pre><code>@Implementation.Validator(annotation = MaxString.class)\npublic class MaxStringLengthValidator implements Validator {\n    ...\n}\n</code></pre>"},{"location":"misc/error-handling/","title":"Error Handling","text":""},{"location":"misc/error-handling/#exceptions","title":"Exceptions","text":"<p>JDA-Commands defines a set of custom runtime exceptions that can occur:</p> <ul> <li><code>ConfigurationException</code> will be thrown if anything goes wrong while configuring JDA-Commands</li> <li><code>InvalidDeclarationException</code> will be thrown if any errors are made in the declaration of interactions</li> <li><code>ParsingException</code> will be thrown if the JSON parsing of the Embed API fails</li> <li><code>InternalException</code> will be thrown if anything goes wrong internally. These errors should be reported to the devs</li> </ul> <p>If a <code>ConfigurationException</code> or <code>InvalidDeclarationException</code> occurs during startup, JDA-Commands will shut down itself as well as JDA. To disable this behaviour, set <code>JDACBuilder#shutdownJDA(boolean)</code> to <code>false</code>. </p>"},{"location":"misc/error-handling/#error-messages","title":"Error Messages","text":"<p>As mentioned before, JDA-Commands has a set of error messages it uses all over the place. These messages include:</p> <ul> <li>Command Execution Failed Message (used for Exceptions)</li> <li>Constraint Failed Message (see Validators)</li> <li>Insufficient Permissions Message (see Permissions System)</li> <li>Timed Out Component Message (see Runtime Concept)</li> <li>Type Adapting Failed Message (see Type Adapters)</li> </ul>"},{"location":"misc/error-handling/#localization","title":"Localization","text":"<p>For simple localization of these error messages you can add a <code>jdac_LOCALE.ftl</code> file to the resources folder and provide the keys/ use the variables as listed below.</p>"},{"location":"misc/error-handling/#type-adapting-failed","title":"Type Adapting Failed","text":"<p>Keys</p> <ul> <li><code>adapting-failed-title</code></li> <li><code>adapting-failed-details</code></li> <li><code>adapting-failed-message</code></li> </ul> <p>Variables</p> <ul> <li><code>command</code>: The full command with parameter names, with the failed argument underlined, for instance: /example arg1 ^^arg2^^</li> <li><code>expected</code>: The expected argument type</li> <li><code>actual</code>: The provided argument type</li> <li><code>raw</code>: The raw, textual user input</li> <li><code>message</code>: The error message of the type adapter</li> </ul>"},{"location":"misc/error-handling/#insufficient-permissions","title":"Insufficient Permissions","text":"<p>Keys</p> <ul> <li><code>insufficient-permissions</code></li> </ul> <p>Variables</p> <ul> <li><code>interaction</code>: The name of the interaction that failed</li> <li><code>permissions</code>: The permissions that are required</li> </ul>"},{"location":"misc/error-handling/#constraint-failed","title":"Constraint Failed","text":"<p>Keys</p> <ul> <li><code>constraint-failed</code></li> </ul> <p>Variables</p> <ul> <li><code>message</code>: The already localized error message of the failed constraint</li> </ul>"},{"location":"misc/error-handling/#interaction-execution-failed","title":"Interaction Execution Failed","text":"<p>Keys</p> <ul> <li><code>execution-failed-title</code></li> <li> <p><code>execution-failed-message</code> Variables</p> </li> <li> <p><code>user</code>: the user executing the interaction</p> </li> <li><code>interaction</code>: the interaction type</li> <li><code>timestamp</code>: the current timestamp</li> <li><code>exception</code>: the name of the exception class</li> </ul>"},{"location":"misc/error-handling/#unknown-interaction","title":"Unknown Interaction","text":"<p>Keys</p> <ul> <li><code>unknown-interaction</code></li> </ul> <p>You can find the default fluent file here.</p>"},{"location":"misc/error-handling/#own-implementation","title":"Own Implementation","text":"<p>You can customize these error messages by providing an implementation of <code>ErrorMessageFactory</code> either at the builder or  by annotating it with <code>Implementation</code>.</p> <p>Example</p> <code>@Implementation</code>Builder Registration <pre><code>@Implementation\npublic class OwnErrorMessageFactory implements ErrorMessageFactory {...}\n</code></pre> <pre><code>JDACommands.builder(jda, Main.class)\n    .errorMessageFactory(new OwnErrorMessageFactory());\n    .start();\n</code></pre>"},{"location":"misc/introspection/","title":"Introspection API","text":"<p>The Introspection API allows you to access JDA-Commands' properties and event system during runtime.</p>"},{"location":"misc/introspection/#accessing-the-api","title":"Accessing the API","text":"<p>To access the API, you can either use</p> <ul> <li><code>JDACommands#introspection()</code> and <code>Event#introspection()</code></li> <li>or <code>Introspection#accessScoped()</code> that will return the instance bound to the current scope</li> </ul>"},{"location":"misc/introspection/#using-scoped-access","title":"Using Scoped Access","text":"<p>When accessing trough <code>Introspection#accessScoped()</code>, you have to pay attention where you do so. An <code>Introspection</code> instance is set in most but not in all places, to know where you can use it take a look at the <code>IntrospectionAccess</code> annotation, which is present on all user implementable methods of JDA-Commands.</p> <p>Inside of interaction controller methods  the <code>Introspection</code> instance is always set with the stage <code>Stage#INTERACTION</code>, providing access to all <code>Properties</code>.</p> <p>Note</p> <p>Internally we use Javas <code>ScopedValue</code>s for this. If you want to know how <code>Introspection#accessScoped()</code> works in regard with Threads make yourself familiar with their docs.</p>"},{"location":"misc/introspection/#getting-properties","title":"Getting Properties","text":"<p>Info</p> <p>Please make yourself conformable with our Properties System before reading this section.</p> <p>The Property System allows accessing all public components and configuration options of JDA-Commands. It can be used to retrieve framework services like <code>MessageResolver</code>, config options like <code>Property#GLOBAL_REPLY_CONFIG</code> or context dependent information like <code>InvocationContext</code>.</p> <p>Sometimes it's required to access such parts of the framework in places were they aren't available as a \"traditional\"  method or constructor parameter. Thus, you can access all parts via properties by using <code>Introspection#get(Property)</code>.</p> <p>Please note that access is read-only, you can't set the value of a <code>Property</code> after starting the framework.</p>"},{"location":"misc/introspection/#stage","title":"Stage","text":"<p>A <code>Property</code>'s value isn't set in all places where you could access it. The value of such properties varies depending on the scope (in code) where you access the <code>Introspection</code> class.</p> <p>To know what property is accessible, take a look at <code>Introspection#currentStage()</code> and compare it to <code>Property#stage()</code>. A hint on the current stage is also provided by <code>IntrospectionAccess#value()</code>, which can be found on user implementable  methods of JDA-Commands.</p> <p>When accessing the Introspection API inside an interaction controller method the stage is always <code>Stage#INTERACTION</code> providing access to all properties.</p>"},{"location":"misc/introspection/#subscribing-to-frameworkevents","title":"Subscribing to <code>FrameworkEvent</code>s","text":"<p>Sometimes it's convenient to execute some custom code at some point during the runtime.</p> <p>An example can be found inside the Guice Extension, were we use a <code>RuntimeCloseEvent</code> to remove the interaction controller instances inside the cache at the end of a conversation.</p> <p>To subscribe to a <code>FrameworkEvent</code> you use <code>Introspection#subscribe(Class, Subscriber)</code> which returns  a <code>Subscription</code> allowing you to \"unsubscribe\" from this event later. If a <code>FrameworkEvent</code> is fired by JDA-Commands all  <code>Subscriber</code>s of that event are called.</p> <p>Warning</p> <p>It's important to know that the events are published by multiple threads perhaps concurrently,  thus <code>Subscriber</code>s may be also called concurrently. They have to be  written with thread-safety in mind!</p>"},{"location":"misc/introspection/#accessing-introspection-inside-subscriber","title":"Accessing <code>Introspection</code> inside <code>Subscriber</code>","text":"<p>A <code>Subscriber</code> provides two arguments:</p> <ul> <li>the published instance of <code>FrameworkEvent</code></li> <li>the <code>Introspection</code> instance used to publish the event</li> </ul> <p>To know in which <code>Stage</code> the event is published (and thus what Properties can be used), take a look at the <code>IntrospectionAccess</code> annotation of the specific <code>FrameworkEvent</code> subclass.</p> <p>For example, <code>InteractionStartEvent</code> has <code>@IntrospectionAccess(Stage.INTERACTION)]</code>, which means that inside of <code>Subscriber&lt;InteractionStartEvent&gt;#accept(InteractionStartEvent, Introspection)]</code> the stage <code>Stage#INTERACTION</code> is set meaning all properties can be accessed.</p> <p>You can also call <code>Introspection#accessScoped()</code> and <code>Introspection#scopedGet(Property)</code> inside of them!</p>"},{"location":"misc/introspection/#example","title":"Example","text":"<pre><code>class MySubscriber implements Subscriber&lt;InteractionStartEvent&gt; {\n\n    public void accept(InteractionStartEvent event, Introspection introspection) { // (2)\n        JDA jda = introspection.get(Property.JDA); // (1)\n\n        User user = event.invocationContext().event().getUser();\n        log.info(\"Started interaction for user: {}\", user.getName());\n    }\n}\n</code></pre> <ol> <li>you can access the introspection instance used to publish this event to get framework components</li> <li><code>InteractionStartEvent</code> has <code>IntrospectionAccess#value()</code> set to <code>Stage#INTERACTION</code>, thus allowing us to access properties available in this stage</li> </ol>"},{"location":"misc/logging/","title":"Logging","text":"<p>JDA-Commands uses SLF4J as its logging framework allowing bot developers to use an own logging backend.</p> <p>If you see following on startup: <pre><code>SLF4J(W): No SLF4J providers were found.\nSLF4J(W): Defaulting to no-operation (NOP) logger implementation\nSLF4J(W): See https://www.slf4j.org/codes.html#noProviders for further details.\n</code></pre></p> <p>and/ or <pre><code>[JDALogger] [WARN] Using fallback logger due to missing SLF4J implementation.\n[JDALogger] [WARN] Please setup a logging framework to use JDA.\n[JDALogger] [WARN] You can use our logging setup guide https://jda.wiki/setup/logging/\n[JDALogger] [WARN] To disable the fallback logger, add the slf4j-nop dependency or use JDALogger.setFallbackLoggerEnabled(false)\n</code></pre></p> <p>It means that you have to configure a logging framework. You can consult the JDA documentation about it.</p> <p>Per default, we will provide a very basic fallback logger based on java.util.logging. Please consult its documentation to know how to configure it.</p> <p>Info</p> <p>Sometimes  <code>java.util.logging</code> is referred to as <code>JUL</code>. Don't be confused, it's the same!</p>"},{"location":"misc/logging/#the-fallback-logger","title":"The Fallback Logger","text":"<p>The fallback logger is a simple SLF4J logger built around java.util.logging.Logger with a log format similar to JDAs fallback logger format.</p> <p>The log levels are translated following:</p> <ul> <li>ERROR -&gt; <code>Level#SEVERE</code> (JUL)</li> <li>WARN -&gt; <code>Level#WARNING</code> (JUL)</li> <li>INFO -&gt; <code>Level#INFO</code> (JUL)</li> <li>DEBUG -&gt; <code>Level#FINE</code> (JUL)</li> <li>TRACE -&gt; <code>Level#FINEST</code> (JUL)</li> </ul>"},{"location":"misc/logging/#debug-mode","title":"Debug Mode","text":"<p>If you want to enable debug logging for the fallback logger you have to somewhere create a <code>logging.properties</code> with following contents:</p> logging.properties<pre><code>.level = FINE\n\nhandlers = java.util.logging.ConsoleHandler\njava.util.logging.ConsoleHandler.level = FINE\n</code></pre> <p>Then add this to your JVM args: <code>-Djava.util.logging.config.file=&lt;your_path_to_logging.properties&gt;</code></p> <p>For example, your Java command could look like this:</p> <pre><code>java -Djava.util.logging.config.file=./app/src/main/resources/logging.properties -jar myBot.jar\n</code></pre> <p>Danger</p> <p>Using the fallback logger is not recommended. As said before, consult the JDA documentation on how to setup proper logging. </p>"},{"location":"misc/property/","title":"Properties","text":"<p>The property system is a core system of JDA-Commands. Its purpose is...</p> <ul> <li>to allow the dynamic and advance configuration of JDA-Commands through our builder and extension system</li> <li>to serve as a central collection point for all values that the user can get during runtime</li> </ul> <p>You can think of it like a really primitive Dependency Injection framework that comes without any annotations. At its heart, there is basically a big <code>Map</code> mapping properties to different PropertyProviders which then provide the value of the property.</p>"},{"location":"misc/property/#properties_1","title":"Properties","text":"<p>As said already, basically the whole system is about properties - but what are they really? Well, properties, as the name says, are properties of JDA-Commands as a whole.  They can be either:</p> <ul> <li>a config option to adjust the behaviour of JDA-Commands</li> <li>an implementation of exposed services</li> <li>or a service provided by the framework that is exposed to the user</li> </ul> <p>Because they're all properties of JDA-Commands, they come predefined as <code>public static final</code> in the <code>Property</code> class and can be accessed by the user. The user can't create own properties!</p>"},{"location":"misc/property/#categories-of-properties","title":"Categories of Properties","text":"<p>To ensure an intuitive configuration experience, properties are primarily categorized in 3 groups:</p> <ul> <li>user settable -&gt; only configurable by using the designated <code>JDACBuilder</code> method</li> <li>user settable + loadable from extension -&gt; above applies plus values can be provided by <code>Extension</code>s</li> <li>provided -&gt; services that are provided by JDA-Commands; the user can use but not create/replace them</li> </ul>"},{"location":"misc/property/#types","title":"Types","text":"<p>Due to the diverse nature of properties, JDA-Commands defines 3 different types of properties:</p>"},{"location":"misc/property/#singleton","title":"Singleton","text":"<p>A <code>Property.Singleton</code> can only have one final instance. For example <code>Localizer</code> is such a property.</p> <p>To decide which value will be used, the priorities of all <code>PropertyProvider</code>s are compared and the highest will be chosen as the provider for this value. To learn more about this, take a look here</p>"},{"location":"misc/property/#enumeration","title":"Enumeration","text":"<p>A <code>Property.Enumeration</code> is basically a <code>Collection</code>, that will consist of the accumulated values of all <code>PropertyProvider</code> for this property.</p> <p>Each <code>PropertyProvider</code> for property <code>T</code> of type <code>enumeration</code> returns an <code>Collection&lt;T&gt;</code>. The returned collections of all <code>PropertyProvider</code>s are then <code>combined</code> into one and used as the final value for this property.</p>"},{"location":"misc/property/#map","title":"Map","text":"<p>A <code>Property.Map</code> is similar to <code>Property.Enumeration</code> except it uses a <code>Map</code> instead a <code>Collection</code>. The values of all <code>PropertyProvider</code>s are accumulated, while the one with higher priority takes precedence.</p> <p>Each <code>PropertyProvider</code> for a property <code>K, V</code> of type <code>map</code> returns an <code>Map&lt;K, V&gt;</code>. The returned maps of all <code>PropertyProvider</code>s are then <code>combined</code> into one and used as the final value for this property.  If multiple <code>PropertyProvider</code>s are setting a value for the same key, then the value of the provider with the highest priority is chosen.</p> <p>Fallback/ Default Values</p> <p>For some properties (like <code>Property#CLASS_FINDER</code>) the default value will be completely overridden instead of accumulated although the propertys type is enumeration or map.</p> <p>Whether the default values will be overridden or accumulated together with other values is defined by <code>Property#fallbackBehaviour()</code></p>"},{"location":"misc/property/#propertyprovider","title":"PropertyProvider","text":"<p>A <code>PropertyProvider</code> provides a value according to the type of the <code>Property</code>. </p> <p>That can either be just a simple instance <code>T</code>, an enumeration <code>Collection&lt;T&gt;</code> or a map <code>Map&lt;K, V&gt;</code>.</p>"},{"location":"misc/property/#priority","title":"Priority","text":"<p>Furthermore, a <code>PropertyProvider</code> has a <code>priority</code> that controls the order in which the values are accumulated. (only important for type singleton and map).</p> <p>Warning</p> <p>The priorities ranging from 0 to 100 and the priority <code>Integer#MAX_VALUE</code> are reserved by JDA-Commands. Internally, we use them as following:</p> <ul> <li>0                     -&gt; fallback/default values provided by JDA-Commands</li> <li><code>Integer#MAX_VALUE</code>   -&gt; all values manually set by the user in <code>JDACBuilder</code></li> </ul>"},{"location":"misc/property/#value-creation","title":"Value Creation","text":"<p>An important fact of <code>PropertyProvider</code>s is, that the value is computed lazily later in the resolution process, not when the <code>PropertyProvider</code> is constructed. If another <code>PropertyProvider</code> is chosen instead of yours (due to higher priority), that means that sometimes your <code>value supplier</code> won't be called at all. </p> <p>However, this allows you to get the values of other properties as dependencies for your own one by calling <code>PropertyProvider.Context#get(Property)</code> inside your <code>supplier</code>.</p> <p>Note</p> <p>If a cycling dependency is detected during the resolution of dependencies, an exception will be thrown providing information on how the recursion occurred.</p>"},{"location":"misc/property/#example-of-propertyprovider-for-propertyclass_finder","title":"Example of <code>PropertyProvider</code> for <code>Property#CLASS_FINDER</code>.","text":"<pre><code>public PropertyProvider&lt;?&gt; provider() {\n    return new PropertyProvider(\n            Property.CLASS_FINDER,\n            200, // just some random non reserved priority\n            Foo.class, //(1)\n            ctx -&gt; List.of(new CustomClassFinder(ctx.get(Property.PACKAGES))) //(2)\n    );\n}\n</code></pre> <ol> <li>The <code>PropertyProvider#referenceClass()</code> value is just used for debugging purpose.    The name of the class will for example be displayed in the cycling dependencies exception messages. </li> <li>The values for <code>Property#PACKAGES</code> will be returned. You can get the value of any property through this method.</li> </ol>"},{"location":"misc/reflection/","title":"Avoiding Reflections","text":"<p>JDA-Commands uses <code>java.lang.reflect</code> in three places:</p> <ul> <li><code>ClassFinder</code></li> <li><code>Descriptor</code></li> <li><code>EmojiSource</code></li> </ul> <p>If you want to completely avoid <code>java.lang.reflect</code> you have to provide your own implementations.</p>"},{"location":"misc/reflection/#classfinder","title":"ClassFinder","text":"<p><code>ClassFinders</code> are used to provide instances of <code>Class</code> that will be scanned for interactions or custom implementations.  You can register at the JDA-Commands Builder.</p> <pre><code>JDACommands.builder(jda, Main.class)\n    .classFinders(new CustomClassFinder())\n    .start();\n</code></pre> <p>Use <code>ClassFinder#explicit(Class...)</code> if you want to explicitly add a <code>Class</code>. </p> <p>Warning</p> <p>Calling <code>JDACBuilder#classFinders(ClassFinder...)</code> will override existing class finders. If you want to keep the default  reflective class finder, you have to add it again via <code>ClassFinder#reflective(String...)</code>. </p> <pre><code>JDACommands.builder(jda, Main.class)\n    .classFinders(ClassFinder.explicit(ForeignClass.class), ClassFinder.reflective(\"com.package\"))\n    .start();\n</code></pre>"},{"location":"misc/reflection/#descriptor","title":"Descriptor","text":"<p>A <code>Descriptor</code> takes a <code>Class</code> as input and transforms it into a <code>ClassDescription</code>. Descriptors can also be registered using the <code>Implementation</code> annotation. Alternatively, register them at the JDA-Commands Builder.</p> <pre><code>JDACommands.builder(jda, Main.class)\n    .descriptor(new CustomDescriptor());\n    .start();\n</code></pre>"},{"location":"misc/reflection/#emojisource","title":"EmojiSource","text":"<p>EmojiSources are used to load application emojis that should be registered automatically upon startup for you.  They're similar to ClassFinders.</p> <p>You can register them at the JDA-Commands Builder or via the <code>Implementation</code> annotation.</p> <pre><code>JDACommands.builder(jda, Main.class)\n    .emojiSources(new CustomEmojiSource())\n    .start();\n</code></pre> <p>Warning</p> <p>Calling <code>emojiSources(...)</code> on the builder will override existing emoji sources. If you want to keep the default reflective emoji source, you have to add it again via <code>EmojiSource#reflective(String...)</code>. </p>"},{"location":"misc/extension/configuring/","title":"Configuring extensions","text":""},{"location":"misc/extension/configuring/#passing-instances-of-extensiondata","title":"Passing instances of <code>Extension.Data</code>","text":"<p>If we want to configure an extension, we can pass an instance of the extension specific implementation of <code>Extension.Data</code> to the JDA-Commands builder. In case of our <code>MyExtension</code> example, that would be:</p> <p>Example</p> <pre><code>JDACommands.builder(jda, Main.class)\n   .extensionData(new MyExtensionData(\"someValue\"))\n   .start();\n</code></pre>"},{"location":"misc/extension/configuring/#filtering-found-extensions","title":"Filtering found Extensions","text":"<p>Filtering extensions is crucial for resolving cycling dependencies. To filter which extensions we want to include in our application, we can utilize the <code>JDACBuilder#filterExtensions(ExtensionFilter.FilterStrategy, String...)</code> method. You need to pass the following two parameters:</p> <ol> <li><code>ExtensionFilter.FilterStrategy</code>,    which will either exclude (<code>FilterStrategy.EXCLUDE</code>) or include (<code>FilterStrategy.INCLUDE</code>) the passed extensions.</li> <li><code>String...</code> is an enumeration of the full class names, which should be either included or excluded.    The strings will be matched to the full class names of the classes extending <code>Extension</code> using <code>String#startWith</code>, thus    specifying package names is possible.</li> </ol> <p>Exclude default Guice Extension</p> <pre><code>JDACommands.builder(jda, Main.class)\n        .filterExtensions(FilterStrategy.EXCLUDE, \"io.github.kaktushose.jdac.guice\")\n        .start();\n</code></pre>"},{"location":"misc/extension/overview/","title":"Overview","text":"<p>Extensions are a way to customize the behaviour of JDA-Commands in a modular style, giving an alternative option to utilizing the JDA-Commands builder.</p> <p>To understand the extension system, you first have to make familiar with JDA-Commands properties concept.</p>"},{"location":"misc/extension/overview/#motivation","title":"Motivation","text":"<p>The reason for adding this rather complicated feature to JDA-Commands is to allow the user to integrate another Dependency Injection Framework than Guice. The default Guice integration is in fact also an extension, which could just be excluded.</p> <p>Additionally, extensions can also be used to share common behavior between bots or to integrate other libraries.</p> <p>Tip</p> <p>For a working example of an extension you can take a look at the default guice extension.</p>"},{"location":"misc/extension/writing/","title":"Writing an Extension","text":""},{"location":"misc/extension/writing/#entrypoint","title":"Entrypoint","text":"<p>The entrypoint of the Extension API is the so called <code>Extension</code> interface, which your extensions \"entry class\" must implement:</p> <pre><code>public class MyExtension implements Extension&lt;?&gt; {}\n</code></pre>"},{"location":"misc/extension/writing/#extensiondata","title":"<code>Extension.Data</code>","text":"<p>Furthermore, each entry class must override the <code>Extension#init(T)</code> method, which will be called when JDA-Commands loads the extension. It can be used to configure extension specific options with help of an own implementation of <code>Extension.Data</code>.</p> <pre><code>public class MyExtension implements Extension&lt;Void&gt; {\n\n    @Override\n    public void init(Void data) {\n        // doing nothing if not needed\n    }\n}\n\npublic class MyExtension implements Extension&lt;MyExtensionData&gt; {\n\n    @Override\n    public void init(MyExtensionData data) { //(1)!\n        if (data != null) {\n            doSomeConfig(data.someOption());\n        }\n    }\n\n    @Override\n    public @NotNull Class&lt;MyExtensionData&gt; dataType() {\n        return MyExtensionData.class;\n    }\n}\n\npublic record MyExtensionData(String someOption) implements Extension.Data {}\n</code></pre> <ol> <li>If no instance of <code>MyExtensionData</code> is passed by the user, this argument will be set <code>null</code>.</li> </ol>"},{"location":"misc/extension/writing/#providing-implementations","title":"Providing Implementations","text":"<p>Currently, extensions support providing custom PropertyProviders of properties with category <code>Property.Category#LOADABLE</code>. You can take a look at <code>Property</code> to know what properties can be provided by extensions. </p> <p>To provide custom <code>PropertyProvider</code>s your have to implement the <code>Extension#properties()</code> method. This method returns a collection of all <code>PropertyProvider</code>s that an extension provides. Take a look here to know how to use them.</p> <pre><code>public class MyExtension implements Extension&lt;MyExtensionData&gt; {\n\n    @Override\n    public void init(MyExtensionData data) {\n        if (data != null) {\n            doSomeConfig(data.someOption());\n        }\n    }\n\n    @Override\n    public @NotNull Collection&lt;Implementation&lt;?&gt;&gt; providedImplementations() {\n        return List.of(new PropertyProvider(\n                Property.CLASS_FINDER,\n                200, // pick an appropriated priority\n                Foo.class,\n                ctx -&gt; List.of(new CustomClassFinder(ctx.get(Priority.PACKAGES)))\n        ));\n    }\n\n    @Override\n    public @NotNull Class&lt;MyExtensionData&gt; dataType() {\n        return MyExtensionData.class;\n    }\n}\n\npublic record MyExtensionData(String someOption) implements Extension.Data {}\n</code></pre>"},{"location":"misc/extension/writing/#registration","title":"Registration","text":"<p>Custom extensions are found with help of Javas ServiceLoader API.</p> <p>To register the above <code>MyExtension</code> we have to create a file in our <code>resources\\META-INF</code> directory called <code>io.github.kaktushose.jdac.configuration.Extension</code>.</p> <pre><code>src\n\u2514\u2500\u2500 main\n    \u2514\u2500\u2500 resources\n        \u2514\u2500\u2500 META-INF\n            \u2514\u2500\u2500 io.github.kaktushose.jdac.configuration.Extension\n</code></pre> <p>The full class name of our class <code>MyExtension</code> (e.g. <code>my.package.MyExtension</code>) must be the content of this file.</p> <p>Example</p> io.github.kaktushose.jdac.configuration.Extension<pre><code>my.package.MyExtension\n</code></pre> <p>The extension can now be found and loaded by JDA-Commands.</p>"},{"location":"start/installation/","title":"Setup","text":""},{"location":"start/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Java 25 or later</li> <li>JDA 6.x</li> <li>SLF4J Implementation (not mandatory, but recommended)</li> </ul>"},{"location":"start/installation/#configuration","title":"Configuration","text":"<p>JDA-Commands is distributed through Maven Central. Alternatively you can download the latest version here.</p> MavenGradle (Kotlin DSL)Gradle (Groovy DSL) pom.xml<pre><code>&lt;dependency&gt;\n   &lt;groupId&gt;io.github.kaktushose&lt;/groupId&gt;\n   &lt;artifactId&gt;jda-commands&lt;/artifactId&gt;\n   &lt;version&gt;4.0.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> build.gradle.kts<pre><code>repositories {\n   mavenCentral()\n}\ndependencies {\n   implementation(\"io.github.kaktushose:jda-commands:4.0.1\")\n}\n</code></pre> build.gradle<pre><code>repositories {\n   mavenCentral()\n}\ndependencies {\n   implementation 'io.github.kaktushose:jda-commands:4.0.1\"'\n}\n</code></pre>"},{"location":"start/installation/#snapshots","title":"Snapshots","text":"<p>Additionally to normal releases, snapshots of each commit to the main branch are published to maven central.</p> MavenGradle (Kotlin DSL)Gradle (Groovy DSL) pom.xml<pre><code>&lt;repositories&gt;\n    &lt;repository&gt;\n        &lt;url&gt;https://central.sonatype.com/repository/maven-snapshots/&lt;/url&gt;\n    &lt;/repository&gt;\n&lt;/repositories&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;io.github.kaktushose&lt;/groupId&gt;\n    &lt;artifactId&gt;jda-commands&lt;/artifactId&gt;\n    &lt;version&gt;4.1.0-SNAPSHOT&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> build.gradle.kts<pre><code>repositories {\n    maven(\"https://central.sonatype.com/repository/maven-snapshots/\")\n}\ndependencies {\n    implementation(\"io.github.kaktushose:jda-commands:4.1.0-SNAPSHOT\")\n}\n</code></pre> build.gradle<pre><code>repositories {\n    maven { url = uri('https://central.sonatype.com/repository/maven-snapshots/') }\n}\ndependencies {\n    implementation 'io.github.kaktushose:jda-commands:4.1.0-SNAPSHOT\"'\n}\n</code></pre>"},{"location":"start/installation/#intellij-plugin","title":"IntelliJ Plugin","text":"<p>We also provide an IntelliJ Plugin that performs some Code Inspection. It validates method references, which are  commonly used in jda-commands. You can find it here.</p> <p> </p>"},{"location":"start/quick-start/","title":"Quick Start Guide","text":""},{"location":"start/quick-start/#entrypoint","title":"Entrypoint","text":"<p>This is the easiest way of starting JDA-Commands. Besides your <code>JDA</code> (or <code>ShardManager</code>) instance, we also need a class of the classpath to scan for interactions. </p> JDAShardManager <pre><code>public class Main {\n\n    void main() {\n        JDA jda = yourJDABuilding();\n        JDACommands.start(jda, Main.class);\n    }\n}\n</code></pre> <pre><code>public class Main {\n\n    void main() {\n        ShardManager shardManager = yourShardManagerBuilding();\n        JDACommands.start(shardManager, Main.class);\n    }\n}\n</code></pre> <p>You can also pass specific packages to exclusively scan: <pre><code>JDACommands.start(jda, Main.class, \"com.example.bot\");\n</code></pre></p>"},{"location":"start/quick-start/#builder","title":"Builder","text":"<p>Some features of JDA-Commands require additional settings. While we provide default values for them, you can also start JDA-Commands using a builder to fine tune some settings:</p> <pre><code>JDACommands.builder(jda, Main.class)\n        // configuration\n        .start();\n</code></pre>"},{"location":"start/quick-start/#defining-interactions","title":"Defining Interactions","text":"<p>You define interactions as methods. They are made up from the method annotations and in some cases the method signature, e.g.  for command options. These methods must be contained in a class annotated with <code>Interaction</code>.</p> <pre><code>@Interaction\npublic class HelloWorld {\n\n    @Command(\"greet\")\n    public void onCommand(CommandEvent event) {\n        event.reply(\"Hello World!\");\n    }\n\n}\n</code></pre> <p>The following interaction types are available:</p> <ul> <li><code>Command</code></li> <li><code>AutoComplete</code></li> <li><code>Command</code></li> <li><code>Button</code></li> <li><code>StringSelectMenu</code></li> <li><code>EntitySelectMenu</code></li> <li><code>Modal</code></li> </ul> <p>You can read more about the different interaction types here.</p>"},{"location":"start/runtime/","title":"Runtime Concept","text":""},{"location":"start/runtime/#overview","title":"Overview","text":"<p>One of the core concepts in JDA-Commands is the so-called <code>Runtime</code>. It will be mentioned frequently here and in the  Javadocs. A <code>Runtime</code> delegates the JDA events to their  corresponding <code>EventHandlers</code> and manages the used virtual threads.</p> <p>A new <code>Runtime</code> is created each time a:</p> <ul> <li><code>SlashCommandInteractionEvent</code></li> <li><code>GenericContextInteractionEvent</code></li> <li><code>CommandAutoCompleteInteractionEvent</code></li> </ul> <p>is provided by JDA or if a component is marked as independent.</p> <p>Runtimes are executed in parallel, but events are processed sequentially by each <code>Runtime</code>. Every <code>EventHandler</code> called by a <code>Runtime</code> is executed in its own virtual thread, isolated from the runtime one.</p> <p>See <code>Lifetime</code> for details when a <code>Runtime</code> will close.</p>"},{"location":"start/runtime/#threading-model","title":"Threading Model","text":"<p>JDA-Commands will listen for incoming events on the <code>JDA MainWS-ReadThread</code>. It will then create a new <code>Runtime</code> or use an existing one, depending on the type of event (see the flowchart below for details). The incoming event is  then passed to the corresponding <code>Runtime</code>.</p> <p>Each <code>Runtime</code> will run in its own virtual thread, called <code>JDAC Runtime-Thread &lt;UUID&gt;</code>. The <code>Runtime</code> will wait for new incoming events and then delegate them to the correct <code>EventHandler</code>. For instance, a <code>SlashCommandInteractionEvent</code> will be passed to the <code>SlashCommandHandler</code>.</p> <p>The <code>EventHandler</code> will again run in its own virtual thread, named <code>JDAC EventHandler-Thread &lt;UUID&gt;</code>, isolated from  the runtime one. Other incoming events are only executed when the previous one has finished. </p> <p>Blocking Methods</p> <p>Because each event has its own virtual thread, you can call blocking methods like JDAs <code>RestAction#complete</code> safely without blocking the <code>JDA MainWS-ReadThread</code>.</p> <p></p>"},{"location":"start/runtime/#lifetime","title":"Lifetime","text":"<p>By default, JDA-Commands will handle the lifetime of Runtimes for you. Every <code>Runtime</code> will be closed if it has benn inactive for 15 minutes. This time span is oriented towards the lifespan of the  <code>InteractionHook</code>. </p>"},{"location":"start/runtime/#explicit","title":"Explicit","text":"<p>You can disable the default behaviour by setting the  <code>ExpirationStrategy</code> to  <code>ExpirationStrategy#EXPLICIT</code>.</p> Main.java<pre><code>JDACommands.builder(jda, Main.class)\n        .expirationStrategy(ExpirationStrategy.EXPLICIT)\n        .start();\n</code></pre> <p>This will prevent any <code>Runtime</code> from closing until <code>Event#closeRuntime()</code> is explicitly called.</p> <p>Example</p> GreetCommand.java<pre><code>@Command(\"greet\")\npublic void onCommand(CommandEvent event) {\n    event.reply(\"Hello World!\");\n    event.closeRuntime();\n}\n</code></pre>"},{"location":"start/runtime/#inactivity","title":"Inactivity","text":"<p>You can also adjust the time frame for a <code>Runtime</code> to be closed.</p> <p>Example</p> <pre><code>JDACommands.builder(jda, Main.class)\n        .expirationStrategy(new ExpirationStrategy.Inactivity(20))//(1)!\n        .start();\n</code></pre> <ol> <li>Note: the duration is always passed as minutes.</li> </ol>"},{"location":"start/runtime/#components-and-modals","title":"Components and Modals","text":""},{"location":"start/runtime/#runtime-bound","title":"Runtime-bound","text":"<p>By default, Buttons, SelectMenus and Modals are <code>runtime-bound</code>. This means that any incoming event will use the same <code>Runtime</code> as the interaction that replied with them. </p> <p>However, this also means that they cannot be executed anymore after the <code>Runtime</code> is closed. JDA-Commands will handle  that case and remove the component. It will also send an ephemeral reply to the user, saying that the  component is no longer available.</p> <p></p> <p>You can customize this error message, find more about it here.</p>"},{"location":"start/runtime/#independent","title":"Independent","text":"<p>You can also reply with components that are <code>runtime-independent</code>, making them virtually immortal. They will create a new <code>Runtime</code> everytime they are executed. </p> <p>These components will even work after a full bot restart! If you want them to not be usable anymore you need to remove  them on your own.</p> <p>Info</p> <p>Modals cannot be independent because they always need a parent interaction that triggers them!</p> <p>Example</p> GreetCommand.java<pre><code>@Command(\"greet\")\npublic void onCommand(CommandEvent event) {\n    event.with().components(Component.independent(\"onButton\")).reply(\"Hello World!\");\n}\n</code></pre> <p>Read more about building replies here.</p>"}]}