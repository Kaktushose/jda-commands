package io.github.kaktushose.jdac.message.i18n;

import dev.goldmensch.fluava.Bundle;
import dev.goldmensch.fluava.Fluava;
import dev.goldmensch.fluava.FluavaBuilder;
import dev.goldmensch.fluava.FluavaBuilder.FunctionConfig;
import dev.goldmensch.fluava.Result;
import dev.goldmensch.fluava.function.Function;
import dev.goldmensch.fluava.function.Value;
import net.dv8tion.jda.api.entities.IMentionable;
import org.jspecify.annotations.Nullable;

import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;

/// The default variant of [Localizer] which implements it with help of the amazing
/// [java implementation](https://github.com/Goldmensch/fluava) of project fluent.
///
/// Due to limitations set by fluent, dots contained in keys will be replaced by `-`.
/// So `my.key` becomes `my-key`. Note that all localization keys generated by jda are also
/// effected by this.
///
/// ### [IMentionable] function
/// By default, this adds a Fluava function that automatically formats [IMentionable] by calling
/// [IMentionable#getAsMention()]. This allows you to directly pass subtypes of [IMentionable] such as member or role
/// as your placeholders.
///
/// You can disable this behavior by calling [`FluavaLocalizer.Builder#mentionableFunction(false)`][Builder#mentionableFunction(boolean)].
/// Alternatively, you can register your own Fluava function at the parent instance called `MENTIONABLE` to override this default implementation.
///
/// @implNote This class caches all loaded bundles. Also, a [sub instance][Fluava#builder(Fluava)] of the passed
/// Fluava instance is created with [FunctionConfig#fallbackToString(boolean)] set to `true`.
public final class FluavaLocalizer implements Localizer {

    private final ConcurrentHashMap<String, Bundle> cache = new ConcurrentHashMap<>();

    private final Fluava fluava;

    /// Constructs a new FluavaLocalizer and adds a Fluava function for [IMentionable].
    ///
    /// @param parent the [Fluava] instance to use
    private FluavaLocalizer(Fluava parent) {
        this.fluava = parent;
    }


    /// Creates a new [FluavaLocalizer.Builder] backed by the passed [Fluava] instance.
    ///
    /// @param parent the backing [Fluava] instance
    /// @return the newly created [FluavaLocalizer.Builder]
    public static FluavaLocalizer.Builder builder(Fluava parent) {
        return new Builder(parent);
    }

    /// Creates a new [FluavaLocalizer] instance backed by the passed [Fluava] instance.
    ///
    /// @param parent the backing [Fluava] instance
    /// @return the newly created [FluavaLocalizer]
    public static FluavaLocalizer create(Fluava parent) {
        return builder(parent).build();
    }


    /// Creates a new [FluavaLocalizer] with [Fluava#fallback()] set to passed locale.
    /// This is just a shorthand for: `FluavaLocalizer.create(Fluava.create(<your locale>))`
    ///
    /// @param fallback the [Locale] used for [FluavaBuilder#fallback(Locale)]
    /// @return the newly created [FluavaLocalizer]
    public static FluavaLocalizer create(Locale fallback) {
        return create(Fluava.create(fallback));
    }

    /// {@inheritDoc}
    ///
    /// For further information regarding functionality, you can take a look at the documentation of:
    ///
    /// - [Fluava#loadBundle(String)] for bundle loading
    /// - [Bundle#apply(java.util.Locale, java.lang.String, java.util.Map)] for localization of a given key
    ///
    /// @param locale    {@inheritDoc}
    /// @param bundle    {@inheritDoc}
    /// @param key       the key to be searched for. Note that all dots will be replaced by `-`.
    /// @param arguments {@inheritDoc}
    /// @return {@inheritDoc}
    @Override
    public Optional<String> localize(Locale locale, String bundle, String key, Map<String, @Nullable  Object> arguments) {
        String result = cache.computeIfAbsent(bundle, fluava::loadBundle).apply(locale, key, arguments);
        return result.equals(key)
                ? Optional.empty()
                : Optional.of(result);
    }

    /// {@inheritDoc}
    ///
    /// For further information regarding functionality, you can take a look at the documentation of:
    ///
    /// - [Fluava#loadBundle(String)] for bundle loading
    /// - [Bundle#apply(java.util.Locale, java.lang.String, java.util.Map)] for localization of a given key
    ///
    /// @param locale    {@inheritDoc}
    /// @param bundle    {@inheritDoc}
    /// @param key       the key to be searched for. Note that all dots (`.`) will be replaced by `-`
    /// @param arguments {@inheritDoc}
    /// @return {@inheritDoc}
    public Optional<String> localizeJDA(Locale locale, String bundle, String key, Map<String, @Nullable Object> arguments) {
        String formattedKey = key.replace('.', '-');
        return localize(locale, bundle, formattedKey, arguments);
    }

    /// A builder allowing the customization of [FluavaLocalizer]
    public static class Builder {
        private boolean mentionableFunction = true;
        private final Fluava parent;

        private Builder(Fluava parent) {
            this.parent = parent;
        }

        /// Whether to create the default [IMentionable] function.
        /// See [FluavaLocalizer] Javadocs for more information.
        ///
        /// @param add `true` if the function should be added
        ///
        /// @return this builder
        public Builder mentionableFunction(boolean add) {
            this.mentionableFunction = add;
            return this;
        }

        public FluavaLocalizer build() {
            Fluava instance = Fluava.builder(parent)
                    .functions(config -> {
                        config.fallbackToString(true);
                        if (mentionableFunction) {
                            config.register("MENTIONABLE", createMentionableFunction(), false);
                        }
                    }).build();

            return new FluavaLocalizer(instance);
        }
    }

    private static Function<?, ?> createMentionableFunction() {
        return Function.implicit(
                (_, mentionable, _) ->
                        new Result.Success<>(new Value.Text(mentionable.getAsMention())), IMentionable.class
        );
    }
}
