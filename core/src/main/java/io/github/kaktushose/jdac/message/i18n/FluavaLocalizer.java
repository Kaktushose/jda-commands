package io.github.kaktushose.jdac.message.i18n;

import net.dv8tion.jda.api.entities.IMentionable;
import dev.goldmensch.fluava.Bundle;
import dev.goldmensch.fluava.Fluava;
import dev.goldmensch.fluava.FluavaBuilder.FunctionConfig;
import dev.goldmensch.fluava.Result;
import dev.goldmensch.fluava.function.Function;
import dev.goldmensch.fluava.function.Value;
import org.jspecify.annotations.Nullable;

import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;

/// The default variant of [Localizer] which implements it with help of the amazing
/// [java implementation](https://github.com/Goldmensch/fluava) of project fluent.
///
/// Due to limitations set by fluent, dots contained in keys will be replaced by `-`.
/// So `my.key` becomes `my-key`. Note that all localization keys generated by jda are also
/// effected by this.
///
/// ### [IMentionable] function
/// By default, this adds a Fluava function that automatically formats [IMentionable] by calling
/// [IMentionable#getAsMention()]. This allows you to directly pass subtypes of [IMentionable] such as member or role
/// as your placeholders.
///
/// You can disable this behavior by calling `#FluavaLocalizer(Fluava, false)`. Alternatively, you can register your
/// own Fluava function at the parent instance called `MENTIONABLE` to override this default implementation.
///
/// @implNote This class caches all loaded bundles. Also, a [sub instance][Fluava#builder(Fluava)] of the passed
/// Fluava instance is created with [FunctionConfig#fallbackToString(boolean)] set to `true`.
public final class FluavaLocalizer implements Localizer {

    private final ConcurrentHashMap<String, Bundle> cache = new ConcurrentHashMap<>();

    private final Fluava fluava;

    /// Constructs a new FluavaLocalizer and adds a Fluava function for [IMentionable].
    ///
    /// @param parent the [Fluava] instance to use
    public FluavaLocalizer(Fluava parent) {
        this(parent, true);
    }

    /// Constructs a new FluavaLocalizer.
    ///
    /// @param parent              the [Fluava] instance to use
    /// @param mentionableFunction whether to add a Fluava function that automatically formats [IMentionable]
    public FluavaLocalizer(Fluava parent, boolean mentionableFunction) {
        this.fluava = Fluava.builder(parent)
                .functions(config -> {
                    config.fallbackToString(true);
                    if (mentionableFunction) {
                        config.register("MENTIONABLE", mentionableFunction());
                    }
                }).build();
    }

    /// {@inheritDoc}
    ///
    /// For further information regarding functionality, you can take a look at the documentation of:
    ///
    /// - [Fluava#loadBundle(String)] for bundle loading
    /// - [Bundle#apply(java.util.Locale, java.lang.String, java.util.Map)] for localization of a given key
    ///
    /// @param locale    {@inheritDoc}
    /// @param bundle    {@inheritDoc}
    /// @param key       the key to be searched for. Note that all dots will be replaced by `-`.
    /// @param arguments {@inheritDoc}
    /// @return {@inheritDoc}
    @Override
    public Optional<String> localize(Locale locale, String bundle, String key, Map<String, @Nullable  Object> arguments) {
        String result = cache.computeIfAbsent(bundle, fluava::loadBundle).apply(locale, key, arguments);
        return result.equals(key)
                ? Optional.empty()
                : Optional.of(result);
    }

    /// {@inheritDoc}
    ///
    /// For further information regarding functionality, you can take a look at the documentation of:
    ///
    /// - [Fluava#loadBundle(String)] for bundle loading
    /// - [Bundle#apply(java.util.Locale, java.lang.String, java.util.Map)] for localization of a given key
    ///
    /// @param locale    {@inheritDoc}
    /// @param bundle    {@inheritDoc}
    /// @param key       the key to be searched for. Note that all dots (`.`) will be replaced by `-`
    /// @param arguments {@inheritDoc}
    /// @return {@inheritDoc}
    public Optional<String> localizeJDA(Locale locale, String bundle, String key, Map<String, @Nullable Object> arguments) {
        String formattedKey = key.replace('.', '-');
        return localize(locale, bundle, formattedKey, arguments);
    }

    private Function<?, ?> mentionableFunction() {
        return Function.implicit(
                (_, mentionable, _) ->
                        new Result.Success<>(new Value.Text(mentionable.getAsMention())), IMentionable.class
        );
    }
}
