{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"JDA-Commands","text":"<p>A declarative, annotation driven interaction framework for JDA. Our goal is to remove any boilerplate code, so  you can focus solely on the business logic of your bot - writing bots has never been easier:</p> CodeExecution <pre><code>@Interaction\npublic class CookieClicker {\n\n    private int counter;//(1)!\n\n    @SlashCommand(value = \"cookie clicker\", desc = \"Play cookie clicker\")\n    public void onClicker(CommandEvent event) {\n        event.with().components(\"onCookie\").reply(\"You've got %s cookie(s)!\", counter);\n    }\n\n    @Button(value = \"Collect\", emoji = \"\ud83c\udf6a\", style = ButtonStyle.SUCCESS)\n    public void onCookie(ComponentEvent event) {\n        event.reply(\"You've got %s cookie(s)!\", ++counter);//(2)!\n    }\n}\n</code></pre> <ol> <li>Yes, that's right! We can store the <code>counter</code> as a class variable. JDA-Commands will create a new instance of   <code>CookieClicker</code> for every command execution, so you don't need to worry about state. You can read more about    it here.</li> <li>This will edit the original message and will also keep the <code>\ud83c\udf6a Collect</code> button attached. You can find find more    about building replies here.</li> </ol> <p></p>"},{"location":"#adding-to-your-project","title":"Adding to your Project","text":"MavenGradle (Kotlin DSL)Gradle (Groovy DSL) pom.xml<pre><code>&lt;dependency&gt;\n   &lt;groupId&gt;io.github.kaktushose&lt;/groupId&gt;\n   &lt;artifactId&gt;jda-commands&lt;/artifactId&gt;\n   &lt;version&gt;4.0.0-beta.4&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> build.gradle.kts<pre><code>repositories {\n   mavenCentral()\n}\ndependencies {\n   implementation(\"io.github.kaktushose:jda-commands:4.0.0-beta.4\")\n}\n</code></pre> build.gradle<pre><code>repositories {\n   mavenCentral()\n}\ndependencies {\n   implementation 'io.github.kaktushose:jda-commands:4.0.0-beta.4\"'\n}\n</code></pre>"},{"location":"#additional-resources","title":"Additional Resources","text":"<p>You might also find the following resources helpful:</p> <ul> <li>Javadocs</li> <li>Release Notes</li> <li>JDA Wiki</li> </ul> <p>Having trouble or found a bug?</p> <ul> <li>Check out the Examples</li> <li>Join the Discord Server</li> <li>Or open an Issue</li> </ul>"},{"location":"di/","title":"Dependency Injection","text":"<p>Dependency injection supports the dependency inversion principle by injecting dependencies into the class definitions  instead of hardcoding them. You'll need dependency injection when using JDA-Commands, because most of your classes, like interaction controllers or middlewares aren't instantiated by  you anymore. </p> <p>JDA-Commands creates one instance of an interaction controller class per runtime. To allow the injection of own Objects in these instances, JDA-Commands provides an interface to integrate a dependency injection framework.</p> <p>Tip</p> <p>Since JDA-Commands is a fundamental part of your discord bot and dependency injection is deeply connected with it, your bot should use a dependency injection framework for all your tasks.</p>"},{"location":"di/#default-dependency-injection-framework-guice","title":"Default Dependency Injection Framework - Guice","text":"<p>Warning</p> <p>For information on how to use Google's Guice, please visit their documentation. This wiki only covers the configuration part. </p> <p>If your using JDA-Commands via the <code>io.github.kaktushose:jda-commands:VERSION</code> artifact, an integration for  Google's Guice is shipped by default. </p> <p>To customize this integration you can pass an instance of <code>GuiceExtensionData</code> to the JDA-Commands builder, which allows you to provide an own instance of Guice's Injector.</p> <p>Configuring Guice</p> <pre><code>Injector yourInjector = Guice.createInjector(new YourOwnGuiceModule());\n\nJDACommands.builder(jda, Main.class)\n        .extensionData(new GuiceExtensionData(yourInjector))\n        .start();\n</code></pre> <p>JDA Object</p> <p>The <code>JDA</code> instance is provided by JDA-Commands and can be obtained via Guice. <pre><code>@Interaction\npublic class GreetCommand {\n\n    private final JDA jda;\n\n    @Inject\n    public GreetCommand(JDA jda) {\n        this.jda = jda;\n    }\n\n    @SlashCommand(\"greet\")\n    public void onCommand(CommandEvent event) { ... }\n}\n</code></pre></p>"},{"location":"di/#implementation-annotation","title":"<code>@Implementation</code> annotation","text":"<p>JDA-Commands has many interfaces to customize specific framework behaviour.  If you're using the Guice integration you can benefit from the convenient <code>@Implementation</code> annotation. </p> <p>This annotation allows the automatic instantiation and registration for implementations of following interfaces:</p> <p>Note</p> <p>If you're annotating an implementation of <code>Middleware</code>, <code>Validator</code> or <code>TypeAdapter</code> you have to provide additional configuration via the <code>@Implementation</code> annotation.</p> <ul> <li>PermissionsProvider</li> <li>GuildScopeProvider</li> <li>ErrorMessageFactory</li> <li> <p>Descriptor</p> </li> <li> <p>Middleware + <code>@Implementation#priority()</code> set</p> </li> <li>Validator + <code>@Implementation#annotation()</code> set</li> <li>TypeAdapter + <code>@Implemenetation#clazz()</code> set</li> </ul> <p>The annotated classes will be instantiated with help of <code>com.google.inject.Injector</code> similar to interaction controllers.</p> <p>Example</p> <pre><code>@Implementation\npublic class CustomGuildScopeProvider implements GuildScopeProvider {\n\n    private final Database database;\n\n    @Inject\n    public HelloWord(Database database) {\n        this.database = database;\n    }\n\n    public Set&lt;Long&gt; apply(CommandData data) { \n        return database.getGuildsForCommand(data);\n    }\n}\n</code></pre>"},{"location":"di/#custom-dependency-injection-integrations","title":"Custom dependency injection integrations","text":"<p>If you want to integrate another dependency injection framework, you have to provide your own  implementation of InteractionControllerInstantiator.</p> <p>You can do this by either passing it to the builder or by creating your own extension.</p> <p>Example</p> <pre><code>JDACommands.builder(jda, Main.class)\n        .instanceProvider(new OwnInterationControllerInstantiator(someContext))\n        .start();\n</code></pre>"},{"location":"extension/configuring/","title":"Configuring extensions","text":""},{"location":"extension/configuring/#passing-instances-of-extensiondata","title":"Passing instances of <code>Extension.Data</code>","text":"<p>If we want to configure an extension, we can pass an instance of the extension specific implementation of <code>Extension.Data</code> to the JDA-Commands builder. In case of our <code>MyExtension</code> example, that would be:</p> <p>Example</p> <pre><code>JDACommands.builder(jda, Main.class)\n   .extensionData(new MyExtensionData(\"someValue\"))\n   .start();\n</code></pre>"},{"location":"extension/configuring/#filtering-found-extensions","title":"Filtering found Extensions","text":"<p>Filtering extensions is crucial for resolving cycling dependencies. To filter which extensions we want to include in our application, we can utilize the <code>JDACBuilder#filterExtensions(JDACBuilder.FilterStrategy, String...)</code> method. You need to pass the following two parameters:</p> <ol> <li><code>JDACBuilder.FilterStrategy</code>,    which will either exclude (<code>FilterStrategy.EXCLUDE</code>) or include (<code>FilterStrategy.INCLUDE</code>) the passed extensions.</li> <li><code>String...</code> is an enumeration of the full class names, which should be either included or excluded.    The strings will be matched to the full class names of the classes extending <code>Extension</code> using <code>String#startWith</code>, thus    specifying package names is possible.</li> </ol> <p>Exclude default Guice Extension</p> <pre><code>JDACommands.builder(jda, Main.class)\n        .filterExtensions(FilterStrategy.EXCLUDE, \"com.github.kaktushose.jda.commands.guice\")\n        .start();\n</code></pre>"},{"location":"extension/overview/","title":"Overview","text":"<p>Extensions are a way to customize the behaviour of JDA-Commands in a modular style, giving an alternative option to utilizing the JDA-Commands builder.</p>"},{"location":"extension/overview/#motivation","title":"Motivation","text":"<p>The reason for adding this rather complicated feature to JDA-Commands is to allow the user to integrate another Dependency Injection Framework than Guice. The default Guice integration is in fact also an extension, which could just be excluded.</p> <p>Additionally, extensions can also be used to share common behavior between bots or to integrate other libraries.</p> <p>Tip</p> <p>For a working example of an extension you can take a look at the default guice extension.</p>"},{"location":"extension/writing/","title":"Writing an Extension","text":""},{"location":"extension/writing/#entrypoint","title":"Entrypoint","text":"<p>The entrypoint of the Extension API is the so called <code>Extension</code> interface, which your extensions \"entry class\" must implement:</p> <pre><code>public class MyExtension implements Extension&lt;?&gt; {}\n</code></pre>"},{"location":"extension/writing/#extensiondata","title":"<code>Extension.Data</code>","text":"<p>Furthermore, each entry class must override the <code>Extension#init(T data)</code> method, which will be called when JDA-Commands loads the extension. It can be used to configure extension specific options with help of an own implementation of <code>Extension.Data</code>.</p> <pre><code>public class MyExtension implements Extension&lt;Void&gt; {\n\n    @Override\n    public void init(Void data) {\n        // doing nothing if not needed\n    }\n}\n\npublic class MyExtension implements Extension&lt;MyExtensionData&gt; {\n\n    @Override\n    public void init(MyExtensionData data) { //(1)!\n        if (data != null) {\n            doSomeConfig(data.someOption());\n        }\n    }\n\n    @Override\n    public @NotNull Class&lt;MyExtensionData&gt; dataType() {\n        return MyExtensionData.class;\n    }\n}\n\npublic record MyExtensionData(String someOption) implements Extension.Data {}\n</code></pre> <ol> <li>If no instance of <code>MyExtensionData</code> is passed by the user, this argument will be set <code>null</code>.</li> </ol>"},{"location":"extension/writing/#providing-implementations","title":"Providing Implementations","text":"<p>Currently, extensions support to provide custom implementations of any class extending <code>ExtensionProvideable</code>, that is:</p> <ul> <li><code>ClassFinder</code></li> <li><code>Descriptor</code></li> <li><code>InteractionControllerInstantiator</code></li> <li><code>ErrorMessageFactory</code></li> <li><code>Implementation.MiddlewareContainer</code> (wrapper type for <code>Middleware</code>)</li> <li><code>Implementation.TypeAdapterContainer</code> (wrapper type for <code>TypeAdapter</code>)</li> <li><code>Implementation.ValidatorContainer</code> (wrapper type for <code>Validator</code>)</li> <li><code>PermissionsProvider</code></li> <li><code>GuildScopeProvider</code></li> </ul> <p>To provide custom implementations we have to implement the <code>Extensions#providedImplementations()</code> method. This method returns a collection of all implementations that an extension provides, wrapped in an instance of <code>Implementation</code>.</p> <pre><code>public class MyExtension implements Extension&lt;MyExtensionData&gt; {\n\n    @Override\n    public void init(MyExtensionData data) {\n        if (data != null) {\n            doSomeConfig(data.someOption());\n        }\n    }\n\n    @Override\n    public @NotNull Collection&lt;Implementation&lt;?&gt;&gt; providedImplementations() {\n        return List.of(new Implementation.single(\n                Descriptor.class,\n                _ -&gt; new MyCustomDescriptor(this))\n        );\n    }\n\n    @Override\n    public @NotNull Class&lt;MyExtensionData&gt; dataType() {\n        return MyExtensionData.class;\n    }\n}\n\npublic record MyExtensionData(String someOption) implements Extension.Data {}\n</code></pre>"},{"location":"extension/writing/#identity-equality","title":"Identity Equality","text":"<p>Warning</p> <p><code>providedImplementations()</code> and the supplier of <code>Implementation</code> will be called multiple times during JDA-Commands startup!</p> <p>Thus, <code>providedImplementations()</code> must always return the same enumeration of <code>Implementation</code>s. If the identity  equality is important, the supplier of <code>Implementation</code> must also always return the same instances.</p> <p>JDA-Commands doesn't rely on identity equality, but you might have fields that store information in that class. It should, of course, be the same instance then each time. </p> <p><code>MyExtension</code> could look something like this in that case:</p> <pre><code>public class MyExtension implements Extension&lt;MyExtensionData&gt; {\n\n    private MyCustomDescriptor descriptor;\n\n    @Override\n    public void init(MyExtensionData data) {\n        if (data != null) {\n            doSomeConfig(data.someOption());\n            descriptor = new MyCustomDescriptor(this);\n        }\n    }\n\n    @Override\n    public @NotNull Collection&lt;Implementation&lt;?&gt;&gt; providedImplementations() {\n        return List.of(new Implementation.single(\n                Descriptor.class,\n                _ -&gt; descriptor)\n        );\n    }\n\n    @Override\n    public @NotNull Class&lt;MyExtensionData&gt; dataType() {\n        return MyExtensionData.class;\n    }\n}\n\npublic record MyExtensionData(String someOption) implements Extension.Data {}\n</code></pre>"},{"location":"extension/writing/#the-implementation-class","title":"The <code>Implementation</code> class","text":"<p>The <code>Implementation</code> class has 2 main purposes: State which class the custom implementation is for and providing instance(s) of those custom implementations.</p> <p>To provide a custom implementation you have to create an instance of <code>Implementation</code> and provide</p> <ol> <li>the <code>type</code> of this Extension (that is a class/interface extending ExtensionProvidable)</li> <li>a <code>supplier</code> in form of <code>java.util.fuction.Function</code> that takes   <code>JDACBuilderData</code>   as an argument and returns a list of instances of custom implementations for the specific type</li> </ol> Example for ClassFinder<pre><code>new Implemenation(\n        ClassFinder.class,\n        builderData -&gt; List.of(new CustomClassFinderOne(), new CustomClassFinderSecond(builderData.descriptor()))\n)\n</code></pre> <p>It's also important that only the following types support multiple instances:</p> <ul> <li><code>ClassFinder</code></li> <li><code>Implementation.MiddlewareContainer</code> (wrapper type for Middleware)</li> <li><code>Implementation.TypeAdapterContainer</code> (wrapper type for TypeAdapter)</li> <li><code>Implementation.ValidatorContainer</code> (wrapper type for Validator)</li> </ul> <p>For all other types <code>single(Class&lt;T&gt;,Function&lt;JDACBuilderData,T&gt; supplier)</code> should be used.</p> <p>The provided instance of <code>JDACBuilderData</code> only supports read access to the builder, which can be used to obtain any other part of the framework as a dependency. It's important to have in mind, that calls to this object will check all registered extensions for the needed implementation, thus cycling dependencies will result in an exception.</p> <p>Tip</p> <p>If the list returned by supplier is empty, this implementation will be treated as non-existent,  which is useful for dynamic registration of custom implementation.</p>"},{"location":"extension/writing/#registration","title":"Registration","text":"<p>Custom extensions are found with help of Javas ServiceLoader API.</p> <p>To register the above <code>MyExtension</code> we have to create a file in our <code>resources\\META-INF</code> directory called <code>com.github.kaktushose.jda.commands.extension.Extension</code>.</p> <pre><code>src\n\u2514\u2500\u2500 main\n    \u2514\u2500\u2500 resources\n        \u2514\u2500\u2500 META-INF\n            \u2514\u2500\u2500 com.github.kaktushose.jda.commands.extension.Extension\n</code></pre> <p>The full class name of our class <code>MyExtension</code> (e.g. <code>my.package.MyExtension</code>) must be the content of this file.</p> <p>Example</p> com.github.kaktushose.jda.commands.extension.Extension<pre><code>my.package.MyExtension\n</code></pre> <p>The extension can now be found and loaded by JDA-Commands.</p>"},{"location":"interactions/commands/","title":"Commands","text":"<p>Info</p> <p>If you're new to JDA and Discord Bots in general, please make yourself familiar with the JDA wiki first. We assume that the basic structure of interactions is known.</p>"},{"location":"interactions/commands/#slash-commands","title":"Slash Commands","text":"<p>SlashCommands are defined by annotating a method with <code>@SlashCommand</code>. The first parameter must always be a <code>CommandEvent</code>. The name and other metadata of the command is passed to the annotation. <pre><code>@SlashCommand(value = \"example\", desc = \"This is an example command\")\npublic void onCommand(CommandEvent event) {...}\n</code></pre></p>"},{"location":"interactions/commands/#sub-commands-sub-command-groups","title":"Sub Commands &amp; Sub Command Groups","text":"<p>In contrast to JDA, JDA-Commands doesn't differentiate between slash commands, sub command groups and sub commands. JDA-Commands determines the type automatically based on the command names. </p> <p>Let's say we have the following commands in our moderation bot: <pre><code>@SlashCommand(\"delete\")\npublic void onDeleteMessages(CommandEvent event) {...}\n\n@SlashCommand(\"moderation warn\")\npublic void onWarnMember(CommandEvent event) {...}\n\n@SlashCommand(\"moderation kick\")\npublic void onKickMember(CommandEvent event) {...}\n\n@SlashCommand(\"moderation ban\")\npublic void onBanMember(CommandEvent event) {...}\n</code></pre> JDA-Commands will create a tree structure of these commands. A depth-first-search is then performed to determine which  commands should be registered as a slash command, a sub command or a sub command group. <pre><code>\u251c\u2500\u2500 delete\n\u2514\u2500\u2500 moderation\n    \u251c\u2500\u2500 warn\n    \u251c\u2500\u2500 kick\n    \u2514\u2500\u2500 ban\n</code></pre></p> Debugging <p>JDA-Commands will log this tree on log-level <code>DEBUG</code>. This might help you with debugging, for example when command  doesn't show up.</p> <p>In our example the following commands will be registered: </p> <ul> <li><code>/delete</code></li> <li><code>/moderation warn</code></li> <li><code>/moderation kick</code></li> <li><code>/moderation ban</code></li> </ul> <p>To simplify things, you can also use the <code>@Interaction</code> to add a base name to all slash commands in a command controller: <pre><code>@Interaction(\"moderation\")\npublic class ModerationCommands {\n\n    @SlashCommand(\"warn\")\n    public void onWarnMember(CommandEvent event) {...}\n\n    @SlashCommand(\"kick\")\n    public void onKickMember(CommandEvent event) {...}\n\n    @SlashCommand(\"ban\")\n    public void onBanMember(CommandEvent event) {...}\n}\n</code></pre></p>"},{"location":"interactions/commands/#command-options","title":"Command Options","text":"<p>You can add command options by simply adding a parameter to the method. <pre><code>@SlashCommand(\"ban\")\npublic void onBanMember(CommandEvent event, Member target, String reason, int delDays) {\n    (...)\n}\n</code></pre> JDA-Commands will attempt to type adapt the  command options. By default, all primitive types, user, member and role as well as text channel entities are  supported. You can find a concrete list of all type adapters here. You can also register your own type adapters.</p> <p>The parameters will automatically be mapped to the correct option type. You can find this mapping  here.</p>"},{"location":"interactions/commands/#name-description","title":"Name &amp; Description","text":"<p>Use the <code>@Param</code> annotation to set a name and a description for a command option. By default, the parameter name will be used as the option name. <pre><code>@SlashCommand(\"ban\")\npublic void onBanMember(CommandEvent event, \n                        @Param(\"The member to ban\") Member target,\n                        @Param(\"The reason to ban the member\") String reason,\n                        @Param(name = \"deletion days\", value = \"The number of days to delete messages for\") int delDays) {\n    (...)\n}\n</code></pre></p> <p>Danger</p> <p>In order for JDA-Commands to use the parameter name as the command option name, you must enable the <code>-parameters</code> compiler flag.</p> MavenGradle (Kotlin DSL)Gradle (Groovy DSL)IntelliJ pom.xml<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n    &lt;configuration&gt;\n        &lt;compilerArgs&gt;\n            &lt;compilerArg&gt;-parameters&lt;/compilerArg&gt;\n        &lt;/compilerArgs&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre> build.gradle.kts<pre><code>tasks.withType&lt;JavaCompile&gt; {\n    options.compilerArgs += \"-parameters\"\n}\n</code></pre> build.gradle<pre><code>compileJava {\n    options.compilerArgs &lt;&lt; '-parameters'\n}\n</code></pre> <p>If you compile your project with IntelliJ during development go to <code>Settings &gt; Compiler &gt; Java Compiler</code> and add the <code>-parameters</code> flag:</p> <p></p>"},{"location":"interactions/commands/#optional","title":"Optional","text":"<p>In order to make a command option optional, annotate the parameter with <code>@Optional</code>. You can also pass a default value that will be used (and type adapted) if no user input is present.  <pre><code>@SlashCommand(\"ban\")\npublic void onBanMember(CommandEvent event, Member target, @Optional String reason, @Optional(\"7\") int delDays) {\n    (...)\n}\n</code></pre></p> <p>Note</p> <p>Required options must be added before non-required options.</p>"},{"location":"interactions/commands/#choices","title":"Choices","text":"<p>Use the <code>@Choices</code> annotation to add choices to a command option: <pre><code>@SlashCommand(\"ban\")\npublic void onBanMember(CommandEvent event, \n                        Member target, \n                        @Choices({\"Harassment\", \"Scam\", \"Advertising\"}) String reason, \n                        int delDays) {\n    (...)\n}\n</code></pre></p>"},{"location":"interactions/commands/#auto-complete","title":"Auto Complete","text":"<p>You can add auto complete to a command option by defining an auto complete handler for it by annotating a method with <code>@AutoComplete</code>. Auto Complete handlers are always bound to one or more slash commands. </p> <p>The slash commands can either be referenced by the:</p> <ol> <li> <p>Command Name</p> <p>If referenced by the command name, the handler will handle any command whose name starts with the given name:</p> <p>Example</p> <pre><code>@SlashCommand(\"favourite fruit\")\n    public void fruitCommand(CommandEvent event, String fruit) {\n    event.reply(\"You've chosen: %s\", fruit);\n}\n\n@SlashCommand(\"favourite vegetable\")\npublic void vegetableCommand(CommandEvent event, String vegetable) {\n    event.reply(\"You've chosen: %s\", vegetable);\n}\n\n@AutoComplete(\"favourite\") //(1)!\npublic void onFavouriteAutoComplete(AutoCompleteEvent event) {\n    event.replyChoices(...);\n}\n</code></pre> <ol> <li>This auto complete handler will receive auto complete events for both <code>/favourite fruit</code> and <code>/favourite vegetable</code></li> </ol> <p>It is also possible to reference the commands by their full name:</p> <p>Example</p> <pre><code>@AutoComplete({\"favourite fruit\", \"favourite vegtable\"})\npublic void onFavouriteAutoComplete(AutoCompleteEvent event) {\n    event.replyChoices(...);\n}\n</code></pre> </li> <li> <p>Method Name</p> <p>If referenced by the method name the handler will only handle the slash command of the given method:</p> <p>Example</p> <pre><code>@SlashCommand(\"favourite fruit\")\npublic void fruitCommand(CommandEvent event, String fruit) {\n    event.reply(\"You've chosen: %s\", fruit);\n}\n\n@AutoComplete(\"fruitCommand\") //(1)!\npublic void onFruitAutoComplete(AutoCompleteEvent event) {\n    event.replyChoices(...);\n}    \n</code></pre> <ol> <li>This auto complete handler will only receive auto complete events for <code>/favourite fruit</code>!</li> </ol> </li> </ol> <p>Warning</p> <p>If an auto complete handler doesn't specify any command options, it will be registered implicitly for every command option of the given slash command(s)!</p> <p>So far we haven't specified which command options should have auto complete, resulting in every command option having  auto complete enabled. If you want to avoid that, you have to explicitly state the command options the handler supports:</p> <p>Example</p> <pre><code>@SlashCommand(\"favourite food\")\npublic void foodCommand(CommandEvent event, String fruit, String vegetable) {\n    event.reply(\"You've chosen: %s and %s\", fruit, vegetable);\n}\n\n@AutoComplete(vale = \"foodCommand\", options = \"fruit\")\npublic void onFruitAutoComplete(AutoCompleteEvent event) {\n    event.replyChoices(...);\n}\n</code></pre> <p>You can have multiple auto complete handler for the same slash command, but each command option can only have exactly  one handler. An auto complete handler that explicitly supports a command option will always be called over a handler  that is implicitly registered.</p>"},{"location":"interactions/commands/#min-max-value","title":"Min &amp; Max Value","text":"<p>Use the <code>@Min</code> or <code>@Max</code> annotation to set the minimum and maximum value for numeral options. </p> <p>Example</p> <pre><code>@SlashCommand(\"ban\")\npublic void onBanMember(CommandEvent event, Member target, String reason, @Max(7) int delDays) {\n    (...)\n}\n</code></pre>"},{"location":"interactions/commands/#context-commands","title":"Context Commands","text":"<p>Both types of context commands are defined by the same <code>@ContextCommand</code> annotation. The first parameter must always be a <code>CommandEvent</code>. The name and other metadata of the command is passed to the annotation.</p>"},{"location":"interactions/commands/#message-context","title":"Message Context","text":"<p>For message context commands the second method parameter must be a <code>Message</code> and the <code>type</code> must be <code>Command.Type.MESSAGE</code>. <pre><code>@ContextCommand(value = \"Delete this message\", type = Command.Type.MESSAGE)\npublic void onDeleteMessage(CommandEvent event, Message target) { ... }\n</code></pre></p>"},{"location":"interactions/commands/#user-context","title":"User Context","text":"<p>For user context commands the second method parameter must be a <code>User</code> and the <code>type</code> must be <code>Command.Type.USER</code>. <pre><code>@ContextCommand(value = \"Ban this user\", type = Command.Type.USER)\npublic void onBanMember(CommandEvent event, User user) { ... }\n</code></pre></p>"},{"location":"interactions/commands/#additional-settings","title":"Additional Settings","text":"<p>Use the <code>@CommandConfig</code> annotation to configure the following settings. You can either annotate a command method directly or annotate the interaction controller class. It is also possible to set a  global command config  at the builder:</p> <p>Global CommandConfig</p> <pre><code>JDACommands.builder(jda, Main.class)\n    .globalCommandConfig(CommandConfig.of(config -&gt; config.nsfw(true))\n    .start();\n</code></pre> <p>JDA-Commands will apply clashing CommandConfigs in the following hierarchy:</p> <ol> <li><code>CommandConfig</code> method annotation</li> <li><code>CommandConfig</code> class annotation</li> <li>global <code>CommandConfig</code></li> </ol>"},{"location":"interactions/commands/#enabledfor","title":"enabledFor","text":"<p>Sets the <code>Discord Permissions</code> a command will be enabled for. By default, a command will be enabled for every permission.</p> <p>Danger</p> <p>Guild admins can modify these permissions at any time! If you want to enforce permissions or secure a critical command further you should use the permissions system of JDA-Commands. You can read more about it here.</p> Slash CommandContext Command <pre><code>@SlashCommand(value = \"example\", enabledFor = Permission.BAN_MEMBERS)\npublic void onCommand(CommandEvent event) {...}\n</code></pre> <pre><code>@ContextCommand(value = \"example\", type = Command.Type.MESSAGE, enabledFor = Permission.BAN_MEMBERS)\npublic void onCommand(CommandEvent event, Message message) {...}\n</code></pre>"},{"location":"interactions/commands/#context","title":"context","text":"<p>Sets the InteractionContextTypes of a command. The default value is <code>InteractionContextType#GUILD</code>.</p> <pre><code>@CommandConfig(context = {InteractionContextType#GUILD, InteractionContextType#BOT_DM})\n@SlashCommand(value = \"example\")\npublic void onCommand(CommandEvent event) {...}\n</code></pre>"},{"location":"interactions/commands/#integration","title":"integration","text":"<p>Sets the IntegrationTypes of a command. The default value is <code>IntegrationType#GUILD_INSTALL</code>.</p> <pre><code>@CommandConfig(integration = {IntegrationType#GUILD_INSTALL, IntegrationType#USER_INSTALL})\n@SlashCommand(value = \"example\")\npublic void onCommand(CommandEvent event) {...}\n</code></pre>"},{"location":"interactions/commands/#isnsfw","title":"isNSFW","text":"<p>Sets whether a command can only be executed in NSFW channels. The default value is <code>false</code>.</p> <pre><code>@CommandConfig(isNSFW = true)\n@SlashCommand(value = \"example\")\npublic void onCommand(CommandEvent event) {...}\n</code></pre>"},{"location":"interactions/commands/#scope-guild-global-commands","title":"scope (Guild &amp; Global Commands)","text":"<p>Sets whether a command should be registered as a <code>global</code> or as a <code>guild</code> command. The default value is <code>global</code>.</p> <pre><code>@CommandConfig(scope = CommandScope.GUILD)\n@SlashCommand(value = \"example\")\npublic void onCommand(CommandEvent event) {...}\n</code></pre> <p>When having guild scoped commands you have to use the <code>GuildScopeProvider</code> to tell JDA-Commands what guilds a command should be registered for. </p> <p>Let's say we have a paid feature in our bot:</p> <p>Example</p> <pre><code>@CommandConfig(scope = CommandScope.GUILD)\n@SlashCommand(value = \"paid feature\")\npublic void onCommand(CommandEvent event) {\n    event.reply(\"Hello World!\");\n}\n</code></pre> <p>We then need to implement a <code>GuildScopeProvider</code> to only register this command for guilds that have paid for that feature:</p> <p>Example</p> <pre><code>public class PremiumGuildsProvider implements GuildScopeProvider {\n\n    @Override\n    public Set&lt;Long&gt; apply(CommandData commandData) {\n        if (commandData.getName().equals(\"paid feature\")) {\n            // this is the place where you could also perform a database lookup\n            return Set.of(1234567890L);\n        }\n        return Set.of();\n    }\n}\n</code></pre> <p>Finally, we have to register our <code>PremiumGuildsProvider</code>. We can either pass it to the builder:</p> <p>Example</p> <pre><code>JDACommands.builder(jda, Main.class)\n    .guildScopeProvider(new PremiumGuildsProvider())\n    .start();\n</code></pre> <p>or simply annotate the <code>PremiumGuildsProvider</code> class with <code>@Implementation</code>.</p> <p>Note</p> <p>Using the <code>@Implementation</code> annotation requires the guice integration (shipped by default). You can read more about it here.   </p>"},{"location":"interactions/components/","title":"Components","text":"<p>Note</p> <p>This section only covers how you define components. See the Reply API section to learn how to use them in replies.</p>"},{"location":"interactions/components/#buttons","title":"Buttons","text":"<p>Buttons are defined by annotating a method with <code>@Button</code>.  The first parameter must always be a <code>ComponentEvent</code>. The label and other metadata of the button is passed to the annotation. <pre><code>@Button(\"example\")\npublic void onButton(ComponentEvent event) {...}\n</code></pre></p>"},{"location":"interactions/components/#style","title":"style","text":"<p>Sets the style of a button.</p> <p></p> <p>Example</p> <pre><code>@Button(value = \"example\", style = ButtonStyle.DANGER)\npublic void onButton(ComponentEvent event) {...}\n</code></pre> <p>Note</p> <p><code>ButtonStyle.PREMIUM</code>  is not supported by JDA-Commands.</p>"},{"location":"interactions/components/#emoji","title":"emoji","text":"<p>Sets the emoji of a button.</p> <p>Example</p> <pre><code>@Button(value = \"Emoji\", emoji = \"\ud83e\udd17\")\npublic void onButton(ComponentEvent event) {...}\n</code></pre>"},{"location":"interactions/components/#link","title":"link","text":"<p>Buttons that have a link cannot be executed, but they are still defined like normal buttons.</p> <p>Example</p> <pre><code>@Button(value = \"JDA-Commands Wiki\", link = \"https://kaktushose.github.io/jda-commands/wiki/\")\npublic void onButton(ComponentEvent event) { }\n</code></pre>"},{"location":"interactions/components/#select-menus","title":"Select Menus","text":""},{"location":"interactions/components/#string-select-menus","title":"String Select Menus","text":"<p>String Select Menus are defined by annotating a method with <code>@StringSelectMenu</code>. The first parameter must always be a <code>ComponentEvent</code>. The second parameter must be a <code>List</code>.</p> <p>The placeholder and other metadata of the String Select Menu is passed to the annotation. </p> <p>Select Options are defined by annotating the method with <code>@SelectOption</code>.</p> <p>Example</p> <pre><code>@SelectOption(label= \"Pizza\", value = \"pizza\")\n@SelectOption(label= \"Hamburger\", value = \"hamburger\")\n@SelectOption(label= \"Sushi\", value = \"Sushi\")\n@StringSelectMenu(\"What's your favourite food?\")\npublic void onMenu(ComponentEvent event, List&lt;String&gt; choices) { ... }\n</code></pre>"},{"location":"interactions/components/#min-max-value","title":"Min &amp; Max Value","text":"<p>String Select Menus support up to 25 options. You can set the minimum and maximum value by using the <code>minValue</code> and  <code>maxValue</code> fields.</p> <p>Example</p> <pre><code>@SelectOption(label= \"Pizza\", value = \"pizza\")\n@SelectOption(label= \"Hamburger\", value = \"hamburger\")\n@SelectOption(label= \"Sushi\", value = \"Sushi\")\n...\n@StringSelectMenu(value = \"What's your favourite food?\", minValue = 2, maxValue = 4)\npublic void onMenu(ComponentEvent event, List&lt;String&gt; choices) { ... }\n</code></pre>"},{"location":"interactions/components/#entity-select-menus","title":"Entity Select Menus","text":"<p>Entity Select Menus are defined by annotating a method with <code>@EntitySelectMenu</code>. The first parameter must always be a <code>ComponentEvent</code>. The second parameter must be of type <code>Mentions</code>.</p> <p>Example</p> <pre><code>@EntitySelectMenu(value = SelectTarget.USER, placeholder = \"Who's your favourite user?\")\npublic void onMenu(ComponentEvent event, Mentions mentions) { ... }\n</code></pre>"},{"location":"interactions/components/#channel-types","title":"Channel Types","text":"<p>When using <code>SelectTarget.CHANNEL</code> you can limit the selectable channel types with the <code>channelTypes</code> field.</p> <p>Example</p> <pre><code>@EntitySelectMenu(\n            value = SelectTarget.CHANNEL, \n            placeholder = \"What's your favourite channel?\", \n            channelTypes = {ChannelType.TEXT, ChannelType.VOICE}\n)\npublic void onMenu(ComponentEvent event, Mentions mentions) { ... }\n</code></pre>"},{"location":"interactions/components/#default-values","title":"Default Values","text":"<p>You can set the default values of the Entity Select Menu by using respectively the <code>defaultChannels</code>, <code>defaultRoles</code> or <code>defaultUsers</code> fields. </p> <p>Example</p> <pre><code>@EntitySelectMenu(\n            value = SelectTarget.CHANNEL, \n            placeholder = \"What's your favourite channel?\",\n            defaultChannels = {0123456789L, 9876543210L}\n)\npublic void onMenu(ComponentEvent event, Mentions mentions) { ... }\n</code></pre>"},{"location":"interactions/components/#min-max-value_1","title":"Min &amp; Max Value","text":"<p>Just as for String Select Menus you can set the minimum and maximum value by using the <code>minValue</code> and <code>maxValue</code> fields.</p>"},{"location":"interactions/modals/","title":"Modals","text":""},{"location":"interactions/modals/#overview","title":"Overview","text":"<p>Modals are defined by annotating a method with <code>@Modal</code>. The first parameter must always be a <code>ModalEvent</code>.</p> <pre><code>@Modal(\"My Modal\")\npublic void onModal(ModalEvent event, @TextInput(\"Input\") String input) { ... }\n</code></pre>"},{"location":"interactions/modals/#text-inputs","title":"Text Inputs","text":"<p>You can add text inputs to a modal by adding String parameters annotated with <code>@TextInput</code>. The label and other metadata of the text input is passed to the annotation. </p> <p>Tip</p> <p>Just as for command options, the parameter name will be used for the label by default. However, this requires the  <code>-parameters</code> compiler flag to be enabled. </p> <p>Text Inputs can be configured with the following fields:</p>"},{"location":"interactions/modals/#style","title":"style","text":"<p>Sets the <code>TextInputStyle</code>.  The default value is <code>TextInputStyle.PARAGRAPH</code>.</p> <p>Example</p> <pre><code>@Modal(\"Ban reason\")\npublic void onModal(ModalEvent event, @TextInput(value = \"Reason\", style = TextInputStyle.SHORT) String input) { ... }\n</code></pre>"},{"location":"interactions/modals/#placeholder","title":"placeholder","text":"<p>Sets the placeholder of a text input.</p> <p>Example</p> <pre><code>@Modal(\"Ban reason\")\npublic void onModal(ModalEvent event, @TextInput(value = \"Reason\", placeholder = \"Please give a reason\") String input) { ... }\n</code></pre>"},{"location":"interactions/modals/#defaultvalue","title":"defaultValue","text":"<p>Sets the default value of a text input, which will pre-populate the text input field with the specified String. </p> <p>Example</p> <pre><code>@Modal(\"Ban reason\")\npublic void onModal(ModalEvent event, @TextInput(value = \"Reason\", defaultValue = \"Rule Violation\") String input) { ... }\n</code></pre>"},{"location":"interactions/modals/#minvalue-maxvalue","title":"minValue &amp; maxValue","text":"<p>Sets the minimum and maximum input length of a text input.</p> <p>Example</p> <pre><code>@Modal(\"Ban reason\")\npublic void onModal(ModalEvent event, @TextInput(value = \"Reason\", maxValue = 1000) String input) { ... }\n</code></pre>"},{"location":"interactions/modals/#required","title":"required","text":"<p>Sets whether the text input is required. The default value is <code>true</code>.</p> <p>Example</p> <pre><code>@Modal(\"Ban reason\")\npublic void onModal(ModalEvent event, @TextInput(value = \"Reason\", required = false) String input) { ... }\n</code></pre>"},{"location":"interactions/modals/#replying-with-modals","title":"Replying with Modals","text":"<p>You can reply to <code>CommandEvents</code> and <code>ComponentEvents</code> with a Modal by calling <code>replyModal(methodName)</code> on the event.</p> <p>Example</p> <pre><code>@SlashCommand(\"ban\")\npublic void onCommand(CommandEvent event, User target) {\n    event.replyModal(\"onModal\"); //(1)!\n}\n\n@Modal(\"Ban reason\")\npublic void onModal(ModalEvent event, @TextInput(\"Reason\") String input) { ... }\n</code></pre> <ol> <li>We reference the Modal we want to send via the method name.</li> </ol>"},{"location":"interactions/overview/","title":"Overview","text":"<p>Info</p> <p>Please make yourself familiar with our Runtime Concept before you proceed. This is a  centerpiece of JDA-Commands and a requirement for understanding the following parts.</p>"},{"location":"interactions/overview/#structure","title":"Structure","text":"<p>In JDA-Commands you define interactions as methods. These methods must be contained in a class annotated with  <code>@Interaction</code>, which is also referred to as the interaction controller. </p> <p>Each method controls one interaction. The interaction data gets defined by annotations and sometimes by the method signature.  JDA-Commands will call the method when the interaction gets executed by a user. </p> <p>Tip</p> <p>It is recommended that you define one conversation per class. By conversation, we mean a logical sequence of interactions, for example a Slash Command that is replied to with a Button followed by a Modal.   </p> <pre><code>@Interaction//(1)!\npublic class GreetCommand {\n\n    @SlashCommand(value = \"greet user\", desc = \"Play cookie clicker\")//(2)!\n    public void onGreet(CommandEvent event, @Param(\"The user you want to greet\") User user) {//(3)!\n        event.reply(\"Hello %s\", user.getAsMention());\n    }\n}\n</code></pre> <ol> <li>This marks the <code>GreetCommand</code> class as an interaction controller.</li> <li>This defines the Slash Command and also tells JDA-Commands to call the <code>onGreet</code> method for this command.</li> <li>In that case the method signature also defines part of the interaction.</li> </ol>"},{"location":"interactions/overview/#runtime-scoped-instances","title":"Runtime Scoped Instances","text":"<p>JDA-Commands will create one instance of the interaction controller class per conversation, which is stored in the corresponding Runtime. That way you don't need to worry about the scope of your variables. Even if multiple users execute your interaction simultaneously, they cannot affect the state of other executions. </p> <p>Let's say we have the following code: <pre><code>@Interaction\npublic class CookieClicker {\n\n    private int counter;\n\n    @SlashCommand(value = \"cookie clicker\", desc = \"Play cookie clicker\")//(1)!\n    public void onClicker(CommandEvent event) {\n        event.with().components(\"onCookie\").reply(\"You've got %s cookie(s)!\", counter);\n    }\n\n    @Button(value = \"Collect\", emoji = \"\ud83c\udf6a\", style = ButtonStyle.SUCCESS)//(2)!\n    public void onCookie(ComponentEvent event) {\n        event.reply(\"You've got %s cookie(s)!\", ++counter);\n    }\n\n}\n</code></pre></p> <ol> <li>This will be a command called <code>/cookie clicker</code></li> <li>This will be a button labeled with <code>Collect \ud83c\udf6a</code> </li> </ol> <p>Let's see what's going on here:</p> <ul> <li> <p>The <code>/cookie clicker</code> command is an entrypoint for starting a new conversation. Everytime the command gets executed JDA will hand over a <code>SlashCommandInteractionEvent</code> to JDA-Commands, which is used to create a new Runtime. </p> </li> <li> <p>This Runtime will then create a new instance of the <code>CookieClicker</code> class. This instance is used to execute the <code>onClicker</code> method.</p> </li> <li> <p>When the <code>Collect \ud83c\udf6a</code> button gets clicked the same Runtime and thus the same instance of the  <code>CookieClicker</code> class will be used to execute the <code>onCookie</code> method.</p> </li> <li> <p>This also means the <code>Collect \ud83c\udf6a</code> button is only usable as long as the Runtime is alive and thus the instance of  the <code>CookieClicker</code> class exists. You can circumvent this by making the <code>Collect \ud83c\udf6a</code> button independent.</p> </li> </ul>"},{"location":"interactions/reply/","title":"Reply Building","text":"<p>Note</p> <p>All event types share the same Reply API. JDA-Commands will always acknowledge the interaction event for you.</p>"},{"location":"interactions/reply/#text-messages","title":"Text Messages","text":"<p>The simplest way of sending a reply is using the <code>reply(String)</code> method. This will send a non-ephemeral text message. If the event has already been replied to, this method will edit the  original message instead of sending a new one by default.</p> <p>The <code>reply()</code> method also has some useful overloads, you can find a full list here.</p>"},{"location":"interactions/reply/#reply-configuration","title":"Reply Configuration","text":"<p>You can change this default behaviour by calling <code>with()</code> before sending the reply. This will return a <code>ConfigurableReply</code> object to you, you can use to modify settings:</p> <p>Ephemeral Reply</p> <pre><code>event.with().ephemeral(true).reply(\"Hello World!\");\n</code></pre> <p>Edit Reply</p> <pre><code>event.with().editReply(false).reply(\"Hello World!\");\n</code></pre>"},{"location":"interactions/reply/#components","title":"Components","text":""},{"location":"interactions/reply/#replying-with-components","title":"Replying with Components","text":"<p>The <code>ConfigurableReply</code> object is also used to attach components. You reference components by the name of the method they are defined with, just like we did before with modals.</p> <p>Example</p> <pre><code>@SlashCommand(\"greet\")\npublic void onCommand(CommandEvent event) {\n    event.with.components(\"onButton\").reply(\"Hello World!\"); //(1)!\n}\n\n@Button(\"Greet me!\")\npublic void onButton(ButtonEvent event) { \n    event.reply(\"Hello %s\".formatted(event.getUser().getAsMention()));\n}\n</code></pre> <ol> <li>We reference the Button we want to send via the method name.</li> </ol> <p>You can also omit the text message and only send the component by calling <code>reply()</code> with no arguments.</p>"},{"location":"interactions/reply/#action-rows","title":"Action Rows","text":"<p>Every call to <code>components()</code> will create a new action row. If you want more than one action row you need to call <code>components()</code> multiple times.</p> <p>Example</p> <pre><code>event.with().components(\"firstButton\").components(\"secondButton\").reply();\n</code></pre> <p>If you want to add multiple components to the same action row, just pass the method names to the same <code>components()</code> call.</p> <p>Example</p> <pre><code>event.with.components(\"firstButton\", \"secondButton\").reply();\n</code></pre> <p>Note</p> <p>One action row supports up to 5 buttons but only 1 select menu.</p>"},{"location":"interactions/reply/#enabling-disabling","title":"Enabling &amp; Disabling","text":"<p>By default, all components are enabled. If you want to attach a disabled component, you need to wrap it by calling <code>Component.disabled(methodName)</code>.</p> <p>If you want to add multiple components to the same action row, with some of them enabled and some disabled, you need to wrap all of them.</p> <p>Example</p> <pre><code>event.with.components(Component.disabled(\"firstButton\"), Component.enabled(\"secondButton\")).reply();\n</code></pre>"},{"location":"interactions/reply/#keeping-components","title":"Keeping Components","text":"<p>When working with components and especially when building menus, e.g. a pagination with buttons, it is often needed to keep the components attached, even when editing the original message multiple times. </p> <p>Normally, Discord would remove any  components when sending a message edit, unless they are explicitly reattached.</p> <p>JDA-Commands flips this behaviour and will keep your components attached by default. </p> <p>You can disable this by calling <code>keepComponents(false)</code>:</p> <p>Example</p> <pre><code>event.with().keepComponents(false).reply(\"Message edit!\");\n</code></pre> <p>Alternatively you can call <code>removeComponents()</code> which will remove all components attached to a message.</p> <p>Cookie Clicker Example</p> CodeExecution <pre><code>@Interaction\npublic class CookieClicker {\n\n    private int counter;\n\n    @SlashCommand(value = \"cookie clicker\", desc = \"Play cookie clicker\")\n    public void onClicker(CommandEvent event) {\n        event.with().components(\"onCookie\").reply(\"You've got %s cookie(s)!\", counter);\n    }\n\n    @Button(value = \"Collect\", emoji = \"\ud83c\udf6a\", style = ButtonStyle.SUCCESS)\n    public void onCookie(ComponentEvent event) {\n        event.reply(\"You've got %s cookie(s)!\", ++counter);\n    }\n}\n</code></pre> <p></p>"},{"location":"interactions/reply/#foreign-components","title":"Foreign Components","text":"<p>You can attach components that were defined in a different class by using the <code>Component</code> class again. In addition to the method name, you must also pass the class reference in that case.</p> <p>Example</p> <pre><code>event.with()\n    .components(Component.enabled(ButtonHelpers.class, \"onConfirm\"), Component.enabled(ButtonHelpers.class, \"onDeny\"))\n    .reply(\"Are you sure?\");\n</code></pre> <p>The foreign component will use the original Runtime just like any other component would. If no  instance of the class the component is defined in (<code>ButtonHelpers</code> in the example above) exists yet,  the Runtime will create one instance (and store it for potential future method calls). </p>"},{"location":"interactions/reply/#lifetime","title":"Lifetime","text":"<p>As discussed earlier, Runtimes have a limited lifetime. By default, JDA-Commands will close a Runtime after 15 minutes have passed. </p> <p>Component Lifetime</p> <p>This means all components belonging to that Runtime will stop working after 15 minutes!</p> <p>JDA-Commands will handle this case for you. This error message can be customized.</p> <p></p> <p>If you want to avoid this behaviour, you have to reply with components that are <code>runtime-independent</code>. They will create a new <code>Runtime</code> everytime they are executed. These components will even work after a full bot restart! If you want them to not be usable anymore you need to remove them on your own.</p> <p>Info</p> <p>Modals cannot be independent because they always need a parent interaction that triggers them!</p> <p>Example</p> <pre><code>event.with().components(Component.independent(\"onButton\")).reply(\"Hello World!\");\n</code></pre>"},{"location":"interactions/reply/#embeds","title":"Embeds","text":"<p>Failure</p> <p>The Embed API is currently refactored. This wiki will cover Embeds as soon as the refactoring is done.</p>"},{"location":"interactions/reply/#replyconfig","title":"ReplyConfig","text":"<p>The <code>@ReplyConfig</code> annotation provides a way to modify the default behaviour for the <code>editReply</code>, <code>ephemeral</code> and <code>keepComponents</code> settings.  You can either annotate single methods or entire interaction controllers. </p> <p>ReplyConfig Annotation</p> <pre><code>@Interaction\n@ReplyConfig(ephemeral = true)\npublic class InteractionController {\n\n    @SlashCommand(\"example\")\n    @ReplyConfig(editReply = false)\n    public void onCommand(CommandEvent) {...}\n\n}\n</code></pre> <p>Alternatively, you can set a global reply config at the builder:</p> <p>Global ReplyConfig</p> <pre><code>JDACommands.builder(jda, Main.class)\n    .globalReplyConfig(new ReplyConfig(true, false, false))\n    .start();\n</code></pre> <p>JDA-Commands will apply clashing ReplyConfigs in the following hierarchy:</p> <ol> <li><code>with()#...</code> calls </li> <li><code>ReplyConfig</code> method annotation</li> <li><code>ReplyConfig</code> class annotation</li> <li>global <code>ReplyConfig</code></li> </ol>"},{"location":"middlewares/cooldown/","title":"Slash Command Cooldown","text":"<p>Note</p> <p>The cooldown API is an old and rarely used feature. Thus, revisiting it isn't a top priority in JDA-Commands development.  If you want it to be improved, feel free to open an issue.</p> <p>Slash commands can have a cooldown to limit their usage. The cooldown is applied globally, per user, per command.  You can add a cooldown by annotating a slash command method with <code>@Cooldown</code>.</p> <p>Example</p> <pre><code>@Cooldown(value = 5, timeUnit = TimeUnit.MINUTES)\n@SlashCommand(\"example\")\npublic void onCommand(CommandEvent event) {\n    ...\n}\n</code></pre> <p>If a command still has a cooldown, an error message gets sent to the user.</p> <p></p> <p>You can customize this error message, find more about it here.</p>"},{"location":"middlewares/overview/","title":"Middlewares","text":"<p>Middlewares run just before an interaction event gets dispatched. They are used to perform additional checks or add more  info the <code>InvocationContext</code>. Middlewares are intended to provide a flexible system for extending the execution chain.</p> <p>They are executed based on their <code>Priority</code> in the following order:</p> <ol> <li><code>PERMISSIONS</code>: Middlewares with this priority will always be executed first</li> <li><code>HIGH</code>: Highest priority for custom implementations, will be executed right after internal middlewares</li> <li><code>NORMAL</code>: Default priority</li> <li><code>LOW</code>: Lowest priority, will be executed at the end</li> </ol> <p>If one middleware fails, the entire interaction execution gets immediately aborted and no more middlewares will be executed. </p>"},{"location":"middlewares/overview/#default-middlewares","title":"Default Middlewares","text":"<p>JDA-Commands uses its own Middleware API internally to implement some features. All these features can either be  extended or replaced by the user. You can either register your own implementations at the respective builder method or use the <code>@Implementation</code> annotation.</p> <p>Note</p> <p>Using the <code>@Implementation</code> annotation requires the guice integration (shipped by default). You can read more about it here.</p> <p>Middlewares provided by JDA-Commands include:</p> <ul> <li>Type Adapters</li> <li>Parameter Validation</li> <li>Permissions System</li> <li>Command Cooldown</li> </ul>"},{"location":"middlewares/overview/#writing-own-middlewares","title":"Writing own Middlewares","text":"<p>You can write your own middlewares by implementing the <code>Middleware</code> interface. You can cancel an execution by calling <code>context.cancel(message)</code>.</p> <p>Example</p> <pre><code>public class LoggingMiddleware implements Middleware {\n\n    public void accept(InvocationContext&lt;?&gt; context) {\n        Logger.log(context.event());\n    }\n\n}\n</code></pre> <p>Then, either register your Middleware at the builder: <pre><code>JDACommands.builder(jda, Main.class)\n    .middleware(Priority.NORMAL, new LoggingMiddleware());\n    .start();\n</code></pre></p> <p>or use the <code>@Implementation</code> annotation: <pre><code>@Implementation(priority = Priority.NORMAL)\npublic class LoggingMiddleware implements Middleware {...}\n</code></pre></p>"},{"location":"middlewares/permissions/","title":"Permissions","text":"<p>When it comes to permissions there are essentially two options:</p> <ol> <li> <p>Use the <code>default permissions</code> of a slash command. This defines a set of  permissions of who can use a command by default. This will perform a Discord client side check. </p> </li> <li> <p>Use the permissions system of JDA-Commands described below. This will perform a bot side permissions check guild admins have no influence on.</p> </li> </ol> <p>Danger</p> <p>Guild admins can modify the <code>default permissions</code> of a slash command at any time!  If you want to enforce permissions  or secure a critical command further you should use the permissions system of JDA-Commands.</p>"},{"location":"middlewares/permissions/#adding-permissions-to-an-interaction","title":"Adding Permissions to an Interaction","text":"<p>Use the <code>@Permissions</code> annotation to add permissions to an interaction. This isn't limited to slash commands, but can be any type of interaction. </p> <p>The <code>@Permissions</code> annotation takes an arbitrary amount of Strings as input. Each String defines a <code>permission</code> that must be present. By default, you can pass Discord Permissions, like <code>BAN_MEMBERS</code>. JDA-Commands will then check if the executor has the respective Discord Permission before executing the interaction. </p> <p>Example</p> <pre><code>@Permissions(\"BAN_MEMBERS\")\n@SlashCommand(\"moderation ban\")\npublic void onBan(CommandEvent event, Member target) {...}\n</code></pre> <p>Instead of annotating individual interaction methods, you can also annotate the interaction controller class. Class  annotation permissions and method annotation permissions will be combined. </p> <p>Example</p> <pre><code>@Permissions(\"ADMINISTRATOR\")\npublic class AdminCommands {...}\n</code></pre>"},{"location":"middlewares/permissions/#error-message","title":"Error Message","text":"<p>If a user is lacking permissions, JDA-Commands will send an error message:</p> <p></p> <p>You can customize this error message, find more about it here.</p>"},{"location":"middlewares/permissions/#own-permissions","title":"Own Permissions","text":"<p>You can also set up your own permission system, which goes beyond the usage of Discord Permissions. Since you only pass Strings, you have a lot of freedom in the design. Common design choices are:</p> <ul> <li>Domain based system, e.g. <code>guild.mod.kick</code>, <code>guild.mod.ban</code>, etc. also allowing for wildcards like <code>guild.mod.*</code></li> <li>Role based system, e.g. having a <code>USER</code>, <code>MODERATOR</code>, <code>ADMIN</code>, etc. role</li> </ul> <p>For our example, let's go with a role based system:</p> <p>Example</p> <pre><code>@Permissions({\"MODERATOR\", \"ADMIN\"})\n@SlashCommand(\"moderation ban\")\npublic void onBan(CommandEvent event, Member target) {...}\n</code></pre> <p>The default <code>PermissionsProvider</code> implementation will always fail, because both <code>MODERATOR</code> and <code>ADMIN</code> are invalid, we have to provide our own implementation. </p>"},{"location":"middlewares/permissions/#permissionsprovider-implementation","title":"PermissionsProvider Implementation","text":"<p>The <code>PermissionsProvider</code> has two almost identical <code>hasPermissions(...)</code> methods.</p> <p>The first one gives you an <code>User</code> object, the second one a  <code>Member</code> object. Therefore, the first method is for interactions that are not executed on a guild (e.g. DMs) and the  second method is for interactions that take place on a guild. Both methods also give you access to the  <code>InvocationContext</code>.</p> <p>This distinction does not necessarily have to be relevant. In most cases, the member method can simply call the user method.</p> What's the difference between a Member and a User? <p>Discord differentiates between <code>Users</code> and <code>Members</code>, whereby a <code>User</code> represents a global Discord user, and a  <code>Member</code> represents a Discord user on a specific guild.</p> <p>Example</p> <pre><code>public class RolePermissionsProvider implements PermissionsProvider {\n\n    private final Collection&lt;Long&gt; admins = List.of(1234567890L);\n    private final Collection&lt;Long&gt; moderators = List.of(1234567890L, 987654321L); //(1)!\n\n    @Override\n    public boolean hasPermission(User user, InvocationContext&lt;?&gt; context) {\n        boolean hasPermissions = true; //(2)!\n\n        for (String permission : context.definition().permissions()) {\n            switch (permission) {\n                case \"ADMIN\" -&gt; hasPermissions = admins.contains(user.getIdLong());\n                case \"MODERATOR\" -&gt; hasPermissions = moderators.contains(user.getIdLong());\n                default -&gt; System.out.println(\"Unknown permission: \" + permission);\n            }\n        }\n\n        return hasPermissions;\n    }\n\n    public boolean hasPermission(@NotNull User user, InvocationContext&lt;?&gt; context) {\n        return hasPermission(member.getUser());\n    }\n}\n</code></pre> <ol> <li>This is a very basic example. In a real world application, you should best use a database for this.</li> <li>This has to be <code>true</code>, so that interactions which don't have any permissions defined, don't fail. </li> </ol> <p>Lastly, we have to register our <code>RolePermissionsProvider</code>.</p> <p>Example</p> <code>@Implementation</code> RegistrationBuilder Registration <pre><code>@Implementation\npublic class RolePermissionsProvider implements PermissionsProvider {\n    ...\n}\n</code></pre> <pre><code>JDACommands.builder(jda, Main.class)\n    .permissionsProvider(new RolePermissionsProvider());\n    .start();\n</code></pre>"},{"location":"middlewares/typeadapter/","title":"Type Adapters","text":"<p><code>TypeAdapters</code> are a part of the execution chain. They are used to adapt the input of a slash command to the correct type needed to invoke the method.</p>"},{"location":"middlewares/typeadapter/#default-type-adapters","title":"Default Type Adapters","text":"<p>JDA-Commands provides the following type adapters by default:</p> <ul> <li>all primitive types and their respective wrapper types</li> <li>User</li> <li>Member</li> <li>Role</li> <li>Channel and subtypes (e.g. StageChannel, NewsChannel, etc.)</li> </ul> <p>You can add any of these types as a parameter to your slash command methods. See Command Options for details. These default types will be mapped to the most fitting option type. You can find the mapping here.</p>"},{"location":"middlewares/typeadapter/#writing-own-type-adapters","title":"Writing Own Type Adapters","text":"<p>Example</p> CommandType Adapter (<code>@Implementation</code> Registration)Type Adapter (Builder Registration) <pre><code>@SlashCommand(\"example\")\npublic void onCommand(CommandEvent event, CustomType object) {\n    ...\n}\n</code></pre> <pre><code>@Implementation(clazz = CustomType.class)\npublic class UserProfileTypeAdapter implements TypeAdapter&lt;CustomType&gt; {\n\n    public Optional&lt;CustomType&gt; apply(String raw, GenericInteractionCreateEvent event) {\n        return Optional.of(new CustomType(raw, event));\n    }\n\n}\n</code></pre> <p><pre><code>public class UserProfileTypeAdapter implements TypeAdapter&lt;CustomType&gt; {\n\n    public Optional&lt;CustomType&gt; apply(String raw, GenericInteractionCreateEvent event) {\n        return Optional.of(new CustomType(raw, event));\n    }\n\n}\n</code></pre> <pre><code>JDACommands.builder(jda, Main.class)\n    .adapter(CustomType.class, new UserProfileTypeAdapter());\n    .start();\n</code></pre></p> <p>Tip</p> <p>If your type adapter is simple enough, you could also just use lambda expressions:  <pre><code>JDACommands.builder(jda, Main.class)\n    .adapter(CustomType.class, (raw, event) -&gt; Optional.of(new CustomType(raw, event));\n    .start();\n</code></pre></p> <p>Your own types will always be mapped to <code>OptionType.STRING</code>. If the type adapting fails (an empty <code>Optional</code> is returned) an error message will be sent to the user:</p> <p></p> <p>You can customize this error message, find more about it here.</p>"},{"location":"middlewares/validator/","title":"Validators","text":"<p>Command Options of a Slash Command can have constraints. You can add constraints by annotating the method parameter with the respective annotation. </p>"},{"location":"middlewares/validator/#default-validators","title":"Default Validators","text":"<p>JDA-Commands comes with the following default constraints:</p> <ul> <li><code>@Role</code>:   The member must have the specified guild role. </li> <li><code>@NotRole</code>:   The member must not have the specified guild role. </li> <li><code>@User</code>:   Must be the specified user or member</li> <li><code>@NotUser</code>:   Must not be the specified user or member.</li> <li><code>@Perm</code>:   The user or member that have the specified discord permission.</li> <li><code>@NotPerm</code>:   The user or member that doesn't have the specified discord permission.</li> </ul> <p>The user and role annotations will resolve the snowflake entity dynamically using the respective type adapter. This means that you can either pass an ID or a name. </p> <p>Example</p> <pre><code>@SlashCommand(\"ban\")\npublic void onBan(CommandEvent event, @NotRole(\"Admin\") Member target) {...}\n</code></pre> <p>An error message is sent, if a parameter constraint fails:</p> <p></p> <p>You can customize this error message, find more about it here.</p>"},{"location":"middlewares/validator/#writing-own-validators","title":"Writing own Validators","text":""},{"location":"middlewares/validator/#1-creating-the-annotation","title":"1. Creating the Annotation","text":"<p>First, you need to create an annotation type for your validator. Your annotation must meet the following conditions:</p> <ul> <li> <code>@Target</code> must be <code>ElementType.PARAMETER</code></li> <li> <code>RetentionPolicy</code> must be <code>RUNTIME</code></li> <li> Must be annotated with <code>@Constraint</code> defining the valid types for this annotation. </li> <li> Must contain a <code>message()</code> field for the error message</li> </ul> <p>Example</p> <pre><code>@Target(ElementType.PARAMETER)\n@Retention(RetentionPolicy.RUNTIME)\n@Constraint(String.class)\npublic @interface MaxString {\n\n    int value();\n\n    String message() default \"The given String is too long\";\n\n}\n</code></pre>"},{"location":"middlewares/validator/#2-creating-the-validator","title":"2. Creating the Validator","text":"<p>Secondly, you must create the actual validator by implementing the <code>Validator</code> interface. </p> <p>The <code>apply(...)</code> method will give you the argument (command option) as well as the annotation object untyped, you must cast them on your own. If the constraint shall pass, you must return <code>true</code>, if it fails <code>false</code>. </p> <p>Example</p> <pre><code>public class MaxStringLengthValidator implements Validator {\n\n    @Override\n    public boolean apply(Object argument, Object annotation, InvocationContext&lt;?&gt; context) {\n        MaxString maxString = (MaxString) annotation;\n        return String.valueOf(argument).length() &lt; maxString.value();\n    }\n\n}\n</code></pre>"},{"location":"middlewares/validator/#3-registration","title":"3. Registration","text":"<p>Lastly, you have to register your new validator.</p> <p>Example</p> <code>@Implementation</code> RegistrationBuilder Registration <pre><code>@Implementation(annotation = MaxString.class)\npublic class MaxStringLengthValidator implements Validator {\n    ...\n}\n</code></pre> <pre><code>JDACommands.builder(jda, Main.class)\n    .validator(MaxString.class, new MaxStringLengthValidator());\n    .start();\n</code></pre>"},{"location":"misc/embeds/","title":"Embed API","text":"<p>Failure</p> <p>The Embed API will be refactored soon. For the time being check out the <code>EmbedCache</code>. (Will brake soon!)</p>"},{"location":"misc/error-messages/","title":"Error Messages","text":"<p>As mentioned before, JDA-Commands has a set of error messages it uses all over the place. These messages include:</p> <ul> <li>Command Execution Failed Message (used for Exceptions)</li> <li>Constraint Failed Message (see Validators)</li> <li>Cooldown Message (see Command Cooldown)</li> <li>Insufficient Permissions Message (see Permissions System)</li> <li>Timed Out Component Message (see Runtime Concept)</li> <li>Type Adapting Failed Message (see Type Adapters)</li> </ul> <p>You can customize these error messages by providing an implementation of <code>ErrorMessageFactory</code>. You have to register it at the JDA-Commands Builder: <pre><code>JDACommands.builder(jda, Main.class)\n    .errorMessageFactory(new OwnErrorMessageFactory());\n    .start();\n</code></pre> Or use the <code>@Implementation</code> annotation (requires the Guice Extension): <pre><code>@Implementation\npublic class OwnErrorMessageFactory implements ErrorMessageFactory {...}\n</code></pre></p>"},{"location":"misc/error-messages/#jsonerrormessagefactory","title":"JsonErrorMessageFactory","text":"<p>To make things easier, these error message can also be loaded from a JSON file. Therefore, you have to enable the  <code>JsonErrorMessageFactory</code>. The <code>JsonErrorMessageFactory</code> takes an <code>EmbedCache</code> as input.</p> <p><pre><code>JDACommands.builder(jda, Main.class)\n    .errorMessageFactory(new JsonErrorMessageFactory(new EmbedCache(\"/path/to/json/embeds.json\")));\n    .start();\n</code></pre> The template for the error messages can be found here. The <code>{placeholders}</code> can be placed anywhere in the embeds and will get injected by JDA-Commands.  </p>"},{"location":"misc/localization/","title":"Localization","text":""},{"location":"misc/localization/#localizationfunction-jda","title":"LocalizationFunction (JDA)","text":"<p>JDA uses the <code>LocalizationFunction</code> for localizing slash commands.  You can pass it to the JDA-Commands Builder:</p> <pre><code>LocalizationFunction localizationFunction = ResourceBundleLocalizationFunction...;\n\nJDACommands.builder(jda, Main.class)\n    .localizationFunction(localizationFunction);\n    .start();\n</code></pre> <p>See the JDA Docs for details.</p>"},{"location":"misc/localization/#localization-jda-commands","title":"Localization (JDA-Commands)","text":"<p>Failure</p> <p>Localization of components, modals and replies is currently worked on.  </p>"},{"location":"misc/reflection/","title":"Avoiding Reflections","text":"<p>JDA-Commands uses <code>java.lang.reflect</code> in two places:</p> <ul> <li><code>ClassFinder</code></li> <li><code>Descriptor</code></li> </ul> <p>If you want to completely avoid <code>java.lang.reflect</code> you have to provide your own implementations.</p>"},{"location":"misc/reflection/#classfinder","title":"ClassFinder","text":"<p><code>ClassFinders</code> are used to provide instances of <code>Class</code> that will be scanned for interactions or custom implementations.  You can register at the JDA-Commands Builder.</p> <pre><code>JDACommands.builder(jda, Main.class)\n    .classFinders(new CustomClassFinder());\n    .start();\n</code></pre> <p>Use <code>ClassFinder#explicit(...)</code> if you want to explicitly add a <code>Class</code>. </p> <p>Warning</p> <p>Calling <code>classFinders(...)</code> on the builder will override existing class finders. If you want to keep the default  reflective class finder, you have to add it again via <code>ClassFinder#reflective(...)</code>. </p> <pre><code>JDACommands.builder(jda, Main.class)\n    .classFinders(ClassFinder.explicit(ForeignClass.class), ClassFinder.reflective(Main.class, \"com.package\"));\n    .start();\n</code></pre>"},{"location":"misc/reflection/#descriptor","title":"Descriptor","text":"<p>A <code>Descriptor</code> takes a <code>Class</code> as input and transforms it into a <code>ClassDescription</code>. Descriptors can also be registered using the <code>@Implementation</code> annotation. Alternatively, register them at the JDA-Commands Builder.</p> <pre><code>JDACommands.builder(jda, Main.class)\n    .descriptor(new CustomDescriptor());\n    .start();\n</code></pre>"},{"location":"start/installation/","title":"Setup","text":""},{"location":"start/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Java 23 or later</li> <li>JDA 5.x</li> <li>SLF4J Implementation (not mandatory, but recommended)</li> </ul>"},{"location":"start/installation/#configuration","title":"Configuration","text":"<p>JDA-Commands is distributed through Maven Central. Alternatively you can download the latest version here.</p> MavenGradle (Kotlin DSL)Gradle (Groovy DSL) pom.xml<pre><code>&lt;dependency&gt;\n   &lt;groupId&gt;io.github.kaktushose&lt;/groupId&gt;\n   &lt;artifactId&gt;jda-commands&lt;/artifactId&gt;\n   &lt;version&gt;4.0.0-beta.4&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> build.gradle.kts<pre><code>repositories {\n   mavenCentral()\n}\ndependencies {\n   implementation(\"io.github.kaktushose:jda-commands:4.0.0-beta.4\")\n}\n</code></pre> build.gradle<pre><code>repositories {\n   mavenCentral()\n}\ndependencies {\n   implementation 'io.github.kaktushose:jda-commands:4.0.0-beta.4\"'\n}\n</code></pre>"},{"location":"start/installation/#intellij-plugin","title":"IntelliJ Plugin","text":"<p>We also provide an IntelliJ Plugin that performs some Code Inspection. It validates method references, which are  commonly used in jda-commands. You can find it here.</p> <p> </p>"},{"location":"start/quick-start/","title":"Quick Start Guide","text":""},{"location":"start/quick-start/#entrypoint","title":"Entrypoint","text":"<p>This is the easiest way of starting JDA-Commands. Besides your <code>JDA</code> (or <code>ShardManager</code>) instance, we also need a class of the classpath to scan for interactions. </p> JDAShardManager <pre><code>public class Main {\n\n    public static void main(String[] args) {\n        JDA jda = yourJDABuilding();\n        JDACommands.start(jda, Main.class);\n    }\n}\n</code></pre> <pre><code>public class Main {\n\n    public static void main(String[] args) {\n        ShardManager shardManager = yourShardManagerBuilding();\n        JDACommands.start(shardManager, Main.class);\n    }\n}\n</code></pre> <p>You can also pass specific packages to exclusively scan: <pre><code>JDACommands.start(jda, Main.class, \"com.example.bot.commands\");\n</code></pre></p>"},{"location":"start/quick-start/#builder","title":"Builder","text":"<p>Some features of JDA-Commands require additional settings. While we provide default values for them, you can also start JDA-Commands using a builder to fine tune some settings:</p> <pre><code>JDACommands.builder(jda, Main.class)\n        // configuration\n        .start();\n</code></pre>"},{"location":"start/quick-start/#defining-interactions","title":"Defining Interactions","text":"<p>You define interactions as methods. They are made up from the method annotations and in some cases the method signature, e.g.  for command options. These methods must be contained in a class annotated with <code>@Interaction</code>.</p> <pre><code>@Interaction\npublic class HelloWorld {\n\n    @SlashCommand(\"greet\")\n    public void onCommand(CommandEvent event) {\n        event.reply(\"Hello World!\");\n    }\n\n}\n</code></pre> <p>The following interaction types are available:</p> <ul> <li><code>@SlashCommand</code></li> <li><code>@AutoComplete</code></li> <li><code>@ContextCommand</code></li> <li><code>@Button</code></li> <li><code>@StringSelectMenu</code></li> <li><code>@EntitySelectMenu</code></li> <li><code>@Modal</code></li> </ul> <p>You can read more about the different interaction types here.</p>"},{"location":"start/runtime/","title":"Runtime Concept","text":""},{"location":"start/runtime/#overview","title":"Overview","text":"<p>One of the core concepts in JDA-Commands is the so-called <code>Runtime</code>. It will be mentioned frequently here and in the  Javadocs. A <code>Runtime</code> delegates the JDA events to their  corresponding <code>EventHandlers</code> and manages the used virtual threads.</p> <p>A new <code>Runtime</code> is created each time a:</p> <ul> <li><code>SlashCommandInteractionEvent</code></li> <li><code>GenericContextInteractionEvent</code></li> <li><code>CommandAutoCompleteInteractionEvent</code></li> </ul> <p>is provided by JDA or if an interaction is marked as independent.</p> <p>Runtimes are executed in parallel, but events are processed sequentially by each <code>Runtime</code>. Every <code>EventHandler</code> called by a <code>Runtime</code> is executed in its own virtual thread, isolated from the runtime one.</p> <p>See <code>Lifetime</code> for details when a <code>Runtime</code> will close.</p>"},{"location":"start/runtime/#threading-model","title":"Threading Model","text":"<p>JDA-Commands will listen for incoming events on the <code>JDA MainWS-ReadThread</code>. It will then create a new <code>Runtime</code> or use an existing one, depending on the type of event (see the flowchart below for details). The incoming event is  then passed to the corresponding <code>Runtime</code>.</p> <p>Each <code>Runtime</code> will run in its own virtual thread, called <code>JDAC Runtime-Thread &lt;UUID&gt;</code>. The <code>Runtime</code> will wait for new incoming events and then delegate them to the correct <code>EventHandler</code>. For instance, a <code>SlashCommandInteractionEvent</code> will be passed to the <code>SlashCommandHandler</code>.</p> <p>The <code>EventHandler</code> will again run in its own virtual thread, named <code>JDAC EventHandler-Thread &lt;UUID&gt;</code>, isolated from  the runtime one. Other incoming events are only executed when the previous one has finished. </p> <p>Blocking Methods</p> <p>Because each event has its own virtual thread, you can call blocking methods like JDAs <code>RestAction#complete</code> safely without blocking the <code>JDA MainWS-ReadThread</code>.</p> <p></p>"},{"location":"start/runtime/#lifetime","title":"Lifetime","text":"<p>By default, JDA-Commands will handle the lifetime of Runtimes for you. Every <code>Runtime</code> will be closed 15 minutes  after its creation. This time span is oriented towards the lifespan of the  <code>InteractionHook</code>. </p>"},{"location":"start/runtime/#explicit","title":"Explicit","text":"<p>You can disable the default behaviour by setting the  <code>ExpirationStrategy</code> to  <code>EXPLICIT</code>.</p> Main.java<pre><code>JDACommands.builder(jda, Main.class)\n        .expirationStrategy(ExpirationStrategy.EXPLICIT)\n        .start();\n</code></pre> <p>This will prevent any <code>Runtime</code> from closing until <code>closeRuntime</code> is explicitly called.</p> <p>Example</p> GreetCommand.java<pre><code>@SlashCommand(\"greet\")\npublic void onCommand(CommandEvent event) {\n    event.reply(\"Hello World!\");\n    event.closeRuntime();\n}\n</code></pre>"},{"location":"start/runtime/#inactivity","title":"Inactivity","text":"<p>You can also adjust the time frame for a <code>Runtime</code> to be closed.</p> <p>Example</p> <pre><code>JDACommands.builder(jda, Main.class)\n        .expirationStrategy(new ExpirationStrategy.Inactivity(20))//(1)!\n        .start();\n</code></pre> <ol> <li>Note: the duration is always passed as minutes.</li> </ol>"},{"location":"start/runtime/#components-and-modals","title":"Components and Modals","text":""},{"location":"start/runtime/#runtime-bound","title":"Runtime-bound","text":"<p>By default, Buttons, SelectMenus and Modals are <code>runtime-bound</code>. This means that any incoming event will use the same <code>Runtime</code> as the interaction that replied with them. </p> <p>However, this also means that they cannot be executed anymore after the <code>Runtime</code> is closed. JDA-Commands will handle  that case and remove the component. It will also send an ephemeral reply to the user, saying that the  component is no longer available.</p> <p></p> <p>You can customize this error message, find more about it here.</p>"},{"location":"start/runtime/#independent","title":"Independent","text":"<p>You can also reply with components that are <code>runtime-independent</code>, making them virtually immortal. They will create a new <code>Runtime</code> everytime they are executed. </p> <p>These components will even work after a full bot restart! If you want them to not be usable anymore you need to remove  them on your own.</p> <p>Info</p> <p>Modals cannot be independent because they always need a parent interaction that triggers them!</p> <p>Example</p> GreetCommand.java<pre><code>@SlashCommand(\"greet\")\npublic void onCommand(CommandEvent event) {\n    event.with().components(Component.independent(\"onButton\")).reply(\"Hello World!\");\n}\n</code></pre> <p>Read more about building replies here.</p>"}]}