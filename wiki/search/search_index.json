{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"JDA-Commands","text":"<p>A declarative, annotation driven interaction framework for JDA. Our goal is to remove any boilerplate code, so  you can focus solely on the business logic of your bot - writing bots has never been easier:</p> CodeExecution <pre><code>@Interaction\npublic class CookieClicker {\n\n    private int counter;//(1)!\n\n    @SlashCommand(value = \"cookie clicker\", desc = \"Play cookie clicker\")\n    public void onClicker(CommandEvent event) {\n        event.with().components(\"onCookie\").reply(\"You've got %s cookie(s)!\", counter);\n    }\n\n    @Button(value = \"Collect\", emoji = \"\ud83c\udf6a\", style = ButtonStyle.SUCCESS)\n    public void onCookie(ComponentEvent event) {\n        event.reply(\"You've got %s cookie(s)!\", ++counter);//(2)!\n    }\n}\n</code></pre> <ol> <li>Yes, that's right! We can store the <code>counter</code> as a class variable. JDA-Commands will create a new instance of   <code>CookieClicker</code> for every command execution, so you don't need to worry about state. You can read more about    it here.</li> <li>This will edit the original message and will also keep the <code>\ud83c\udf6a Collect</code> button attached. You can find find more    about building replies here.</li> </ol> <p></p>"},{"location":"#adding-to-your-project","title":"Adding to your Project","text":"MavenGradle (Kotlin DSL)Gradle (Groovy DSL) pom.xml<pre><code>&lt;dependency&gt;\n   &lt;groupId&gt;io.github.kaktushose&lt;/groupId&gt;\n   &lt;artifactId&gt;jda-commands&lt;/artifactId&gt;\n   &lt;version&gt;4.0.0-beta.4&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> build.gradle.kts<pre><code>repositories {\n   mavenCentral()\n}\ndependencies {\n   implementation(\"io.github.kaktushose:jda-commands:4.0.0-beta.4\")\n}\n</code></pre> build.gradle<pre><code>repositories {\n   mavenCentral()\n}\ndependencies {\n   implementation 'io.github.kaktushose:jda-commands:4.0.0-beta.4\"'\n}\n</code></pre>"},{"location":"#additional-resources","title":"Additional Resources","text":"<p>You might also find the following resources helpful:</p> <ul> <li>Javadocs</li> <li>Release Notes</li> <li>JDA Wiki</li> </ul> <p>Having trouble or found a bug?</p> <ul> <li>Check out the Examples</li> <li>Join the Discord Server</li> <li>Or open an Issue</li> </ul>"},{"location":"di/","title":"Overview","text":"<p>As noted in here JDA-Commands creates one instance of an interaction controller class per runtime. To allow the injection of own Objects in these instances, JDA-Commands provides an interface to integrate a dependency injection framework.</p>"},{"location":"di/#default-dependency-injection-framework-guice","title":"Default Dependency Injection Framework - Guice","text":"<p>If your using JDA-Commands via the \"io.github.kaktushose:jda-commands:\" artifact, an integration for  Google's Guice is shipped by default.  <p>To customize this integration you can provide an instance of <code>io.github.kaktushose.jda.commands.guice.GuiceExtensionData</code>, which allows you to provide an own instance of <code>com.google.inject.Injector</code>.  Please visit the Guice Wiki for further information on how to customize Google Guice.</p>"},{"location":"di/#the-implementation-annotation","title":"The <code>@Implementation</code> annotation","text":"<p>JDA-Commands has many interfaces to customize specific framework behaviour.  If you're using the Guice integration you can benefit from the convenient @Implementation annotation. </p> <p>This annotation allows the automatic instantiation and registration for implementations of following interfaces:</p> <ul> <li>PermissionsProvider</li> <li>GuildScopeProvider</li> <li>ErrorMessageFactory</li> <li> <p>Descriptor</p> </li> <li> <p>Middleware + <code>@Implementation#priority()</code> set</p> </li> <li>Validator + <code>@Implementation#annotation()</code> set</li> <li>TypeAdapter + <code>@Implemenetation#clazz()</code> set</li> </ul> <p>Info</p> <p>If you're annotating an implementation of <code>Middleware</code>, <code>Validator</code> or <code>TypeAdapter</code> you have to provide additional configuration via the <code>@Implementation</code> annotation.</p> <p>The annotated classes will be instantiated with help of <code>com.google.inject.Injector</code> similar to interaction controllers.</p>"},{"location":"di/#custom-dependency-injection-integrations","title":"Custom dependency injection integrations","text":"<p>If you want to integrate another dependency injection framework, you have to provide an own  implementation of <code>com.github.kaktushose.jda.commands.dispatching.instance.InteractionControllerInstantiator</code>.</p>"},{"location":"interactions/commands/","title":"Commands","text":"<p>Info</p> <p>If you're new to JDA and Discord Bots in general, please make yourself familiar with the JDA wiki first. We assume that the basic structure of interactions is known.</p>"},{"location":"interactions/commands/#slash-commands","title":"Slash Commands","text":"<p>SlashCommands are defined by annotating a method with <code>@SlashCommand</code>. The first parameter must always be a <code>CommandEvent</code>. The name and other metadata of the command is passed to the annotation. <pre><code>@SlashCommand(value = \"example\", desc = \"This is an example command\")\npublic void onCommand(CommandEvent event) {...}\n</code></pre></p>"},{"location":"interactions/commands/#sub-commands-sub-command-groups","title":"Sub Commands &amp; Sub Command Groups","text":"<p>In contrast to JDA, JDA-Commands doesn't differentiate between slash commands, sub command groups and sub commands. JDA-Commands determines the type automatically based on the command names. </p> <p>Let's say we have the following commands in our moderation bot: <pre><code>@SlashCommand(\"delete\")\npublic void onDeleteMessages(CommandEvent event) {...}\n\n@SlashCommand(\"moderation warn\")\npublic void onWarnMember(CommandEvent event) {...}\n\n@SlashCommand(\"moderation kick\")\npublic void onKickMember(CommandEvent event) {...}\n\n@SlashCommand(\"moderation ban\")\npublic void onBanMember(CommandEvent event) {...}\n</code></pre> JDA-Commands will create a tree structure of these commands. A depth-first-search is then performed to determine which  commands should be registered as a slash command, a sub command or a sub command group. <pre><code>\u251c\u2500\u2500 delete\n\u2514\u2500\u2500 moderation\n    \u251c\u2500\u2500 warn\n    \u251c\u2500\u2500 kick\n    \u2514\u2500\u2500 ban\n</code></pre></p> Debugging <p>JDA-Commands will log this tree on log-level <code>DEBUG</code>. This might help you with debugging, for example when command  doesn't show up.</p> <p>In our example the following commands will be registered: </p> <ul> <li><code>/delete</code></li> <li><code>/moderation warn</code></li> <li><code>/moderation kick</code></li> <li><code>/moderation ban</code></li> </ul> <p>To simplify things, you can also use the <code>@Interaction</code> to add a base name to all slash commands in a command controller: <pre><code>@Interaction(\"moderation\")\npublic class ModerationCommands {\n\n    @SlashCommand(\"warn\")\n    public void onWarnMember(CommandEvent event) {...}\n\n    @SlashCommand(\"kick\")\n    public void onKickMember(CommandEvent event) {...}\n\n    @SlashCommand(\"ban\")\n    public void onBanMember(CommandEvent event) {...}\n}\n</code></pre></p>"},{"location":"interactions/commands/#command-options","title":"Command Options","text":"<p>You can add command options by simply adding a parameter to the method. <pre><code>@SlashCommand(\"ban\")\npublic void onBanMember(CommandEvent event, Member target, String reason, int delDays) {\n    (...)\n}\n</code></pre> JDA-Commands will attempt to type adapt the  command options. By default, all primitive types, user, member and role as well as text channel entities are  supported. You can find a concrete list of all type adapters here. You can also register your own type adapters.</p> <p>The parameters will automatically be mapped to the correct option type. You can find this mapping  here.</p>"},{"location":"interactions/commands/#name-description","title":"Name &amp; Description","text":"<p>Use the <code>@Param</code> annotation to set a name and a description for a command option. By default, the parameter name will be used as the option name. <pre><code>@SlashCommand(\"ban\")\npublic void onBanMember(CommandEvent event, \n                        @Param(\"The member to ban\") Member target,\n                        @Param(\"The reason to ban the member\") String reason,\n                        @Param(name = \"deletion days\", value = \"The number of days to delete messages for\") int delDays) {\n    (...)\n}\n</code></pre></p> <p>Danger</p> <p>In order for JDA-Commands to use the parameter name as the command option name, you must enable the <code>-parameters</code> compiler flag.</p> MavenGradle (Kotlin DSL)Gradle (Groovy DSL)IntelliJ pom.xml<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n    &lt;configuration&gt;\n        &lt;compilerArgs&gt;\n            &lt;compilerArg&gt;-parameters&lt;/compilerArg&gt;\n        &lt;/compilerArgs&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre> build.gradle.kts<pre><code>tasks.withType&lt;JavaCompile&gt; {\n    options.compilerArgs += \"-parameters\"\n}\n</code></pre> build.gradle<pre><code>compileJava {\n    options.compilerArgs &lt;&lt; '-parameters'\n}\n</code></pre> <p>If you compile your project with IntelliJ during development go to <code>Settings &gt; Compiler &gt; Java Compiler</code> and add the <code>-parameters</code> flag:</p> <p></p>"},{"location":"interactions/commands/#optional","title":"Optional","text":"<p>In order to make a command option optional, annotate the parameter with <code>@Optional</code>. You can also pass a default value that will be used (and type adapted) if no user input is present.  <pre><code>@SlashCommand(\"ban\")\npublic void onBanMember(CommandEvent event, Member target, @Optional String reason, @Optional(\"7\") int delDays) {\n    (...)\n}\n</code></pre></p> <p>Note</p> <p>Required options must be added before non-required options.</p>"},{"location":"interactions/commands/#choices","title":"Choices","text":"<p>Use the <code>@Choices</code> annotation to add choices to a command option: <pre><code>@SlashCommand(\"ban\")\npublic void onBanMember(CommandEvent event, \n                        Member target, \n                        @Choices({\"Harassment\", \"Scam\", \"Advertising\"}) String reason, \n                        int delDays) {\n    (...)\n}\n</code></pre></p>"},{"location":"interactions/commands/#auto-complete","title":"Auto Complete","text":"<p>Failure</p> <p>The Auto Complete API will be refactored soon. This wiki will cover Auto Complete as soon as the refactoring is done.</p>"},{"location":"interactions/commands/#context-commands","title":"Context Commands","text":"<p>Both types of context commands are defined by the same <code>@ContextCommand</code> annotation. The first parameter must always be a <code>CommandEvent</code>. The name and other metadata of the command is passed to the annotation.</p>"},{"location":"interactions/commands/#message-context","title":"Message Context","text":"<p>For message context commands the second method parameter must be a <code>Message</code> and the <code>type</code> must be <code>Command.Type.MESSAGE</code>. <pre><code>@ContextCommand(value = \"Delete this message\", type = Command.Type.MESSAGE)\npublic void onDeleteMessage(CommandEvent event, Message target) { ... }\n</code></pre></p>"},{"location":"interactions/commands/#user-context","title":"User Context","text":"<p>For user context commands the second method parameter must be a <code>User</code> and the <code>type</code> must be <code>Command.Type.USER</code>. <pre><code>@ContextCommand(value = \"Ban this user\", type = Command.Type.USER)\npublic void onBanMember(CommandEvent event, User user) { ... }\n</code></pre></p>"},{"location":"interactions/commands/#additional-settings","title":"Additional Settings","text":"<p>Both the <code>@SlashCommand</code>  annotation and the <code>@ContextCommand</code> annotation share the following fields.</p>"},{"location":"interactions/commands/#isguildonly","title":"isGuildOnly","text":"<p>Sets whether a command is only usable in a guild. This only has an effect if the command is registered globally.  The default value is <code>false</code>.</p> Slash CommandContext Command <pre><code>@SlashCommand(value = \"example\", isGuildOnly = true)\npublic void onCommand(CommandEvent event) {...}\n</code></pre> <pre><code>@ContextCommand(value = \"example\", type = Command.Type.MESSAGE, isGuildOnly = true)\npublic void onCommand(CommandEvent event, Message message) {...}\n</code></pre>"},{"location":"interactions/commands/#isnsfw","title":"isNSFW","text":"<p>Sets whether a command can only be executed in NSFW channels. The default value is <code>false</code>.</p> Slash CommandContext Command <pre><code>@SlashCommand(value = \"example\", isNSFW = true)\npublic void onCommand(CommandEvent event) {...}\n</code></pre> <pre><code>@ContextCommand(value = \"example\",  type = Command.Type.MESSAGE, isNSFW = true)\npublic void onCommand(CommandEvent event, Message message) {...}\n</code></pre>"},{"location":"interactions/commands/#enabledfor","title":"enabledFor","text":"<p>Sets the <code>Discord Permissions</code> a command will be enabled for. By default, a command will be enabled for every permission.</p> <p>Danger</p> <p>Guild admins can modify these permissions at any time! If you want to enforce permissions or secure a critical command further you should use the permissions system of JDA-Commands. You can read more about it here.</p> Slash CommandContext Command <pre><code>@SlashCommand(value = \"example\", enabledFor = Permission.BAN_MEMBERS)\npublic void onCommand(CommandEvent event) {...}\n</code></pre> <pre><code>@ContextCommand(value = \"example\", type = Command.Type.MESSAGE, enabledFor = Permission.BAN_MEMBERS)\npublic void onCommand(CommandEvent event, Message message) {...}\n</code></pre>"},{"location":"interactions/commands/#scope-guild-global-commands","title":"scope (Guild &amp; Global Commands)","text":"<p>Sets whether a command should be registered as a <code>global</code> or as a <code>guild</code> command. The default value is <code>global</code>.</p> <p>Note</p> <p>User installable apps are currently not supported by JDA-Commands.</p> Slash CommandContext Command <pre><code>@SlashCommand(value = \"example\", scope = CommandScope.GUILD)\npublic void onCommand(CommandEvent event) {...}\n</code></pre> <pre><code>@ContextCommand(value = \"example\", type = Command.Type.MESSAGE, scope = CommandScope.GUILD)\npublic void onCommand(CommandEvent event, Message message) {...}\n</code></pre> <p>When having guild scoped commands you have to use the <code>GuildScopeProvider</code> to tell JDA-Commands what guilds a command should be registered for. </p> <p>Let's say we have a paid feature in our bot:</p> <p>Example</p> <pre><code>@SlashCommand(value = \"paid feature\", scope = CommandScope.GUILD)\npublic void onCommand(CommandEvent event) {\n    event.reply(\"Hello World!\");\n}\n</code></pre> <p>We then need to implement a <code>GuildScopeProvider</code> to only register this command for guilds that have paid for that feature:</p> <p>Example</p> <pre><code>public class PremiumGuildsProvider implements GuildScopeProvider {\n\n    @Override\n    public Set&lt;Long&gt; apply(CommandData commandData) {\n        if (commandData.getName().equals(\"paid feature\")) {\n            // this is the place where you could also perform a database lookup\n            return Set.of(1234567890L);\n        }\n        return Set.of();\n    }\n}\n</code></pre> <p>Finally, we have to register our <code>PremiumGuildsProvider</code>. We can either pass it to the builder:</p> <p>Example</p> <pre><code>JDACommands.builder()\n    .guildScopeProvider(new PremiumGuildsProvider())\n    .start(jda, Main.class);\n</code></pre> <p>or simply annotate the <code>PremiumGuildsProvider</code> class with <code>@Implementation</code>.</p> <p>Note</p> <p>Using the <code>@Implementation</code> annotation requires the guice integration (shipped by default). You can read more about it here.   </p>"},{"location":"interactions/components/","title":"Components","text":"<p>Note</p> <p>This section only covers how you define components. See the Reply API section to learn how to use them in replies.</p>"},{"location":"interactions/components/#buttons","title":"Buttons","text":"<p>Buttons are defined by annotating a method with <code>@Button</code>.  The first parameter must always be a <code>ComponentEvent</code>. The label and other metadata of the button is passed to the annotation. <pre><code>@Button(\"example\")\npublic void onButton(ComponentEvent event) {...}\n</code></pre></p>"},{"location":"interactions/components/#style","title":"style","text":"<p>Sets the style of a button.</p> <p></p> <p>Example</p> <pre><code>@Button(value = \"example\", style = ButtonStyle.DANGER)\npublic void onButton(ComponentEvent event) {...}\n</code></pre> <p>Note</p> <p><code>ButtonStyle.PREMIUM</code>  is not supported by JDA-Commands.</p>"},{"location":"interactions/components/#emoji","title":"emoji","text":"<p>Sets the emoji of a button.</p> <p>Example</p> <pre><code>@Button(value = \"Emoji\", emoji = \"\ud83e\udd17\")\npublic void onButton(ComponentEvent event) {...}\n</code></pre>"},{"location":"interactions/components/#link","title":"link","text":"<p>Buttons that have a link cannot be executed, but they are still defined like normal buttons.</p> <p>Example</p> <pre><code>@Button(value = \"JDA-Commands Wiki\", link = \"https://kaktushose.github.io/jda-commands/wiki/\")\npublic void onButton(ComponentEvent event) { }\n</code></pre>"},{"location":"interactions/components/#select-menus","title":"Select Menus","text":""},{"location":"interactions/components/#string-select-menus","title":"String Select Menus","text":"<p>String Select Menus are defined by annotating a method with <code>@StringSelectMenu</code>. The first parameter must always be a <code>ComponentEvent</code>. The second parameter must be a <code>List</code>.</p> <p>The placeholder and other metadata of the String Select Menu is passed to the annotation. </p> <p>Select Options are defined by annotating the method with <code>@SelectOption</code>.</p> <p>Example</p> <pre><code>@SelectOption(label= \"Pizza\", value = \"pizza\")\n@SelectOption(label= \"Hamburger\", value = \"hamburger\")\n@SelectOption(label= \"Sushi\", value = \"Sushi\")\n@StringSelectMenu(\"What's your favourite food?\")\npublic void onMenu(ComponentEvent event, List&lt;String&gt; choices) { ... }\n</code></pre>"},{"location":"interactions/components/#min-max-value","title":"Min &amp; Max Value","text":"<p>String Select Menus support up to 25 options. You can set the minimum and maximum value by using the <code>minValue</code> and  <code>maxValue</code> fields.</p> <p>Example</p> <pre><code>@SelectOption(label= \"Pizza\", value = \"pizza\")\n@SelectOption(label= \"Hamburger\", value = \"hamburger\")\n@SelectOption(label= \"Sushi\", value = \"Sushi\")\n...\n@StringSelectMenu(value = \"What's your favourite food?\", minValue = 2, maxValue = 4)\npublic void onMenu(ComponentEvent event, List&lt;String&gt; choices) { ... }\n</code></pre>"},{"location":"interactions/components/#entity-select-menus","title":"Entity Select Menus","text":"<p>Entity Select Menus are defined by annotating a method with <code>@EntitySelectMenu</code>. The first parameter must always be a <code>ComponentEvent</code>. The second parameter must be of type <code>Mentions</code>.</p> <p>Example</p> <pre><code>@EntitySelectMenu(value = SelectTarget.USER, placeholder = \"Who's your favourite user?\")\npublic void onMenu(ComponentEvent event, Mentions mentions) { ... }\n</code></pre>"},{"location":"interactions/components/#channel-types","title":"Channel Types","text":"<p>When using <code>SelectTarget.CHANNEL</code> you can limit the selectable channel types with the <code>channelTypes</code> field.</p> <p>Example</p> <pre><code>@EntitySelectMenu(\n            value = SelectTarget.CHANNEL, \n            placeholder = \"What's your favourite channel?\", \n            channelTypes = {ChannelType.TEXT, ChannelType.VOICE}\n)\npublic void onMenu(ComponentEvent event, Mentions mentions) { ... }\n</code></pre>"},{"location":"interactions/components/#default-values","title":"Default Values","text":"<p>You can set the default values of the Entity Select Menu by using respectively the <code>defaultChannels</code>, <code>defaultRoles</code> or <code>defaultUsers</code> fields. </p> <p>Example</p> <pre><code>@EntitySelectMenu(\n            value = SelectTarget.CHANNEL, \n            placeholder = \"What's your favourite channel?\",\n            defaultChannels = {0123456789L, 9876543210L}\n)\npublic void onMenu(ComponentEvent event, Mentions mentions) { ... }\n</code></pre>"},{"location":"interactions/components/#min-max-value_1","title":"Min &amp; Max Value","text":"<p>Just as for String Select Menus you can set the minimum and maximum value by using the <code>minValue</code> and <code>maxValue</code> fields.</p>"},{"location":"interactions/modals/","title":"Modals","text":""},{"location":"interactions/modals/#overview","title":"Overview","text":"<p>Modals are defined by annotating a method with <code>@Modal</code>. The first parameter must always be a <code>ModalEvent</code>.</p> <pre><code>@Modal(\"My Modal\")\npublic void onModal(ModalEvent event, @TextInput(\"Input\") String input) { ... }\n</code></pre>"},{"location":"interactions/modals/#text-inputs","title":"Text Inputs","text":"<p>You can add text inputs to a modal by adding String parameters annotated with <code>@TextInput</code>. The label and other metadata of the text input is passed to the annotation. </p> <p>Tip</p> <p>Just as for command options, the parameter name will be used for the label by default. However, this requires the  <code>-parameters</code> compiler flag to be enabled. </p> <p>Text Inputs can be configured with the following fields:</p>"},{"location":"interactions/modals/#style","title":"style","text":"<p>Sets the <code>TextInputStyle</code>.  The default value is <code>TextInputStyle.PARAGRAPH</code>.</p> <p>Example</p> <pre><code>@Modal(\"Ban reason\")\npublic void onModal(ModalEvent event, @TextInput(value = \"Reason\", style = TextInputStyle.SHORT) String input) { ... }\n</code></pre>"},{"location":"interactions/modals/#placeholder","title":"placeholder","text":"<p>Sets the placeholder of a text input.</p> <p>Example</p> <pre><code>@Modal(\"Ban reason\")\npublic void onModal(ModalEvent event, @TextInput(value = \"Reason\", placeholder = \"Please give a reason\") String input) { ... }\n</code></pre>"},{"location":"interactions/modals/#defaultvalue","title":"defaultValue","text":"<p>Sets the default value of a text input, which will pre-populate the text input field with the specified String. </p> <p>Example</p> <pre><code>@Modal(\"Ban reason\")\npublic void onModal(ModalEvent event, @TextInput(value = \"Reason\", defaultValue = \"Rule Violation\") String input) { ... }\n</code></pre>"},{"location":"interactions/modals/#minvalue-maxvalue","title":"minValue &amp; maxValue","text":"<p>Sets the minimum and maximum input length of a text input.</p> <p>Example</p> <pre><code>@Modal(\"Ban reason\")\npublic void onModal(ModalEvent event, @TextInput(value = \"Reason\", maxValue = 1000) String input) { ... }\n</code></pre>"},{"location":"interactions/modals/#required","title":"required","text":"<p>Sets whether the text input is required. The default value is <code>true</code>.</p> <p>Example</p> <pre><code>@Modal(\"Ban reason\")\npublic void onModal(ModalEvent event, @TextInput(value = \"Reason\", required = false) String input) { ... }\n</code></pre>"},{"location":"interactions/modals/#replying-with-modals","title":"Replying with Modals","text":"<p>You can reply to <code>CommandEvents</code> and <code>ComponentEvents</code> with a Modal by calling <code>replyModal(methodName)</code> on the event.</p> <p>Example</p> <pre><code>@SlashCommand(\"ban\")\npublic void onCommand(CommandEvent event, User target) {\n    event.replyModal(\"onModal\"); //(1)!\n}\n\n@Modal(\"Ban reason\")\npublic void onModal(ModalEvent event, @TextInput(\"Reason\") String input) { ... }\n</code></pre> <ol> <li>We reference the Modal we want to send via the method name.</li> </ol>"},{"location":"interactions/overview/","title":"Overview","text":"<p>Info</p> <p>Please make yourself familiar with our Runtime Concept before you proceed. This is a  centerpiece of JDA-Commands and a requirement for understanding the following parts.</p>"},{"location":"interactions/overview/#structure","title":"Structure","text":"<p>In JDA-Commands you define interactions as methods. These methods must be contained in a class annotated with  <code>@Interaction</code>, which is also referred to as the interaction controller. </p> <p>Each method controls one interaction. The interaction data gets defined by annotations and sometimes by the method signature.  JDA-Commands will call the method when the interaction gets executed by a user. </p> <p>Tip</p> <p>It is recommended that you define one conversation per class. By conversation, we mean a logical sequence of interactions, for example a Slash Command that is replied to with a Button followed by a Modal.   </p> <pre><code>@Interaction//(1)!\npublic class GreetCommand {\n\n    @SlashCommand(value = \"greet user\", desc = \"Play cookie clicker\")//(2)!\n    public void onGreet(CommandEvent event, @Param(\"The user you want to greet\") User user) {//(3)!\n        event.reply(\"Hello %s\", user.getAsMention());\n    }\n}\n</code></pre> <ol> <li>This marks the <code>GreetCommand</code> class as an interaction controller.</li> <li>This defines the Slash Command and also tells JDA-Commands to call the <code>onGreet</code> method for this command.</li> <li>In that case the method signature also defines part of the interaction.</li> </ol>"},{"location":"interactions/overview/#runtime-scoped-instances","title":"Runtime Scoped Instances","text":"<p>JDA-Commands will create one instance of the interaction controller class per conversation, which is stored in the corresponding Runtime. That way you don't need to worry about the scope of your variables. Even if multiple users execute your interaction simultaneously, they cannot affect the state of other executions. </p> <p>Let's say we have the following code: <pre><code>@Interaction\npublic class CookieClicker {\n\n    private int counter;\n\n    @SlashCommand(value = \"cookie clicker\", desc = \"Play cookie clicker\")//(1)!\n    public void onClicker(CommandEvent event) {\n        event.with().components(\"onCookie\").reply(\"You've got %s cookie(s)!\", counter);\n    }\n\n    @Button(value = \"Collect\", emoji = \"\ud83c\udf6a\", style = ButtonStyle.SUCCESS)//(2)!\n    public void onCookie(ComponentEvent event) {\n        event.reply(\"You've got %s cookie(s)!\", ++counter);\n    }\n\n}\n</code></pre></p> <ol> <li>This will be a command called <code>/cookie clicker</code></li> <li>This will be a button labeled with <code>Collect \ud83c\udf6a</code> </li> </ol> <p>Let's see what's going on here:</p> <ul> <li> <p>The <code>/cookie clicker</code> command is an entrypoint for starting a new conversation. Everytime the command gets executed JDA will hand over a <code>SlashCommandInteractionEvent</code> to JDA-Commands, which is used to create a new Runtime. </p> </li> <li> <p>This Runtime will then create a new instance of the <code>CookieClicker</code> class. This instance is used to execute the <code>onClicker</code> method.</p> </li> <li> <p>When the <code>Collect \ud83c\udf6a</code> button gets clicked the same Runtime and thus the same instance of the  <code>CookieClicker</code> class will be used to execute the <code>onCookie</code> method.</p> </li> <li> <p>This also means the <code>Collect \ud83c\udf6a</code> button is only usable as long as the Runtime is alive and thus the instance of  the <code>CookieClicker</code> class exists. You can circumvent this by making the <code>Collect \ud83c\udf6a</code> button independent.</p> </li> </ul>"},{"location":"interactions/reply/","title":"Reply Building","text":"<p>Note</p> <p>All event types share the same Reply API. JDA-Commands will always acknowledge the interaction event for you.</p>"},{"location":"interactions/reply/#text-messages","title":"Text Messages","text":"<p>The simplest way of sending a reply is using the <code>reply(String)</code> method. This will send a non-ephemeral text message. If the event has already been replied to, this method will edit the  original message instead of sending a new one by default.</p> <p>The <code>reply()</code> method also has some useful overloads, you can find a full list here.</p>"},{"location":"interactions/reply/#reply-configuration","title":"Reply Configuration","text":"<p>You can change this default behaviour by calling <code>with()</code> before sending the reply. This will return a <code>ConfigurableReply</code> object to you, you can use to modify settings:</p> <p>Ephemeral Reply</p> <pre><code>event.with().ephemeral(true).reply(\"Hello World!\");\n</code></pre> <p>Edit Reply</p> <pre><code>event.with().editReply(false).reply(\"Hello World!\");\n</code></pre>"},{"location":"interactions/reply/#components","title":"Components","text":""},{"location":"interactions/reply/#replying-with-components","title":"Replying with Components","text":"<p>The <code>ConfigurableReply</code> object is also used to attach components. You reference components by the name of the method they are defined with, just like we did before with modals.</p> <p>Example</p> <pre><code>@SlashCommand(\"greet\")\npublic void onCommand(CommandEvent event) {\n    event.with.components(\"onButton\").reply(\"Hello World!\"); //(1)!\n}\n\n@Button(\"Greet me!\")\npublic void onButton(ButtonEvent event) { \n    event.reply(\"Hello %s\".formatted(event.getUser().getAsMention()));\n}\n</code></pre> <ol> <li>We reference the Button we want to send via the method name.</li> </ol> <p>You can also omit the text message and only send the component by calling <code>reply()</code> with no arguments.</p>"},{"location":"interactions/reply/#action-rows","title":"Action Rows","text":"<p>Every call to <code>components()</code> will create a new action row. If you want more than one action row you need to call <code>components()</code> multiple times.</p> <p>Example</p> <pre><code>event.with.components(\"firstButton\").components(\"secondButton\").reply();\n</code></pre> <p>If you want to add multiple components to the same action row, just pass the method names to the same <code>components()</code> call.</p> <p>Example</p> <pre><code>event.with.components(\"firstButton\", \"secondButton\").reply();\n</code></pre> <p>Note</p> <p>One action row supports up to 5 buttons but only 1 select menu.</p>"},{"location":"interactions/reply/#enabling-disabling","title":"Enabling &amp; Disabling","text":"<p>By default, all components are enabled. If you want to attach a disabled component, you need to wrap it by calling <code>Component.disabled(methodName)</code>.</p> <p>If you want to add multiple components to the same action row, with some of them enabled and some disabled, you need to wrap all of them.</p> <p>Example</p> <pre><code>event.with.components(Component.disabled(\"firstButton\"), Component.enabled(\"secondButton\")).reply();\n</code></pre>"},{"location":"interactions/reply/#keeping-components","title":"Keeping Components","text":"<p>When working with components and especially when building menus, e.g. a pagination with buttons, it is often needed to keep the components attached, even when editing the original message multiple times. </p> <p>Normally, Discord would remove any  components when sending a message edit, unless they are explicitly reattached.</p> <p>JDA-Commands flips this behaviour and will keep your components attached by default. </p> <p>You can disable this by calling <code>keepComponents(false)</code>:</p> <p>Example</p> <pre><code>event.with().keepComponents(false).reply(\"Message edit!\");\n</code></pre> <p>Alternatively you can call <code>removeComponents()</code> which will remove all components attached to a message.</p> <p>Cookie Clicker Example</p> CodeExecution <pre><code>@Interaction\npublic class CookieClicker {\n\n    private int counter;\n\n    @SlashCommand(value = \"cookie clicker\", desc = \"Play cookie clicker\")\n    public void onClicker(CommandEvent event) {\n        event.with().components(\"onCookie\").reply(\"You've got %s cookie(s)!\", counter);\n    }\n\n    @Button(value = \"Collect\", emoji = \"\ud83c\udf6a\", style = ButtonStyle.SUCCESS)\n    public void onCookie(ComponentEvent event) {\n        event.reply(\"You've got %s cookie(s)!\", ++counter);\n    }\n}\n</code></pre> <p></p>"},{"location":"interactions/reply/#foreign-components","title":"Foreign Components","text":"<p>You can attach components that were defined in a different class by using the <code>Component</code> class again.</p>"},{"location":"interactions/reply/#lifetime","title":"Lifetime","text":""},{"location":"interactions/reply/#embeds","title":"Embeds","text":"<p>Failure</p> <p>The Embed API is currently refactored. This wiki will cover Embeds as soon as the refactoring is done.</p>"},{"location":"interactions/reply/#replyconfig","title":"ReplyConfig","text":""},{"location":"start/installation/","title":"Setup","text":""},{"location":"start/installation/#prerequisites","title":"Prerequisites","text":"<ul> <li>Java 23 or later</li> <li>JDA 5.x</li> <li>SLF4J Implementation (not mandatory, but recommended)</li> </ul>"},{"location":"start/installation/#configuration","title":"Configuration","text":"<p>JDA-Commands is distributed through Maven Central. Alternatively you can download the latest version here.</p> MavenGradle (Kotlin DSL)Gradle (Groovy DSL) pom.xml<pre><code>&lt;dependency&gt;\n   &lt;groupId&gt;io.github.kaktushose&lt;/groupId&gt;\n   &lt;artifactId&gt;jda-commands&lt;/artifactId&gt;\n   &lt;version&gt;4.0.0-beta.4&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> build.gradle.kts<pre><code>repositories {\n   mavenCentral()\n}\ndependencies {\n   implementation(\"io.github.kaktushose:jda-commands:4.0.0-beta.4\")\n}\n</code></pre> build.gradle<pre><code>repositories {\n   mavenCentral()\n}\ndependencies {\n   implementation 'io.github.kaktushose:jda-commands:4.0.0-beta.4\"'\n}\n</code></pre>"},{"location":"start/installation/#intellij-plugin","title":"IntelliJ Plugin","text":"<p>We also provide an IntelliJ Plugin that performs some Code Inspection. It validates method references, which are  commonly used in jda-commands. You can find it here.</p> <p> </p>"},{"location":"start/quick-start/","title":"Quick Start Guide","text":""},{"location":"start/quick-start/#entrypoint","title":"Entrypoint","text":"<p>This is the easiest way of starting JDA-Commands. Besides your <code>JDA</code> (or <code>ShardManager</code>) instance, we also need a class of the classpath to scan for interactions. </p> JDAShardManager <pre><code>public class Main {\n\n    public static void main(String[] args) {\n        JDA jda = yourJDABuilding();\n        JDACommands.start(jda, Main.class);\n    }\n}\n</code></pre> <pre><code>public class Main {\n\n    public static void main(String[] args) {\n        ShardManager shardManager = yourShardManagerBuilding();\n        JDACommands.start(shardManager, Main.class);\n    }\n}\n</code></pre> <p>You can also pass specific packages to exclusively scan: <pre><code>JDACommands.start(jda, Main.class, \"com.example.bot.commands\");\n</code></pre></p>"},{"location":"start/quick-start/#builder","title":"Builder","text":"<p>Some features of JDA-Commands require additional settings. While we provide default values for them, you can also start JDA-Commands using a builder to fine tune some settings:</p> <pre><code>JDACommands.builder(jda, Main.class)\n        // configuration\n        .start();\n</code></pre>"},{"location":"start/quick-start/#defining-interactions","title":"Defining Interactions","text":"<p>You define interactions as methods. They are made up from the method annotations and in some cases the method signature, e.g.  for command options. These methods must be contained in a class annotated with <code>@Interaction</code>.</p> <pre><code>@Interaction\npublic class HelloWorld {\n\n    @SlashCommand(\"greet\")\n    public void onCommand(CommandEvent event) {\n        event.reply(\"Hello World!\");\n    }\n\n}\n</code></pre> <p>The following interaction types are available:</p> <ul> <li><code>@SlashCommand</code></li> <li><code>@AutoComplete</code></li> <li><code>@ContextCommand</code></li> <li><code>@Button</code></li> <li><code>@StringSelectMenu</code></li> <li><code>@EntitySelectMenu</code></li> <li><code>@Modal</code></li> </ul> <p>You can read more about the different interaction types here.</p>"},{"location":"start/runtime/","title":"Runtime Concept","text":""},{"location":"start/runtime/#overview","title":"Overview","text":"<p>One of the core concepts in JDA-Commands is the so-called <code>Runtime</code>. It will be mentioned frequently here and in the  Javadocs. A <code>Runtime</code> delegates the JDA events to their  corresponding <code>EventHandlers</code> and manages the used virtual threads.</p> <p>A new <code>Runtime</code> is created each time a:</p> <ul> <li><code>SlashCommandInteractionEvent</code></li> <li><code>GenericContextInteractionEvent</code></li> <li><code>CommandAutoCompleteInteractionEvent</code></li> </ul> <p>is provided by JDA or if an interaction is marked as independent.</p> <p>Runtimes are executed in parallel, but events are processed sequentially by each <code>Runtime</code>. Every <code>EventHandler</code> called by a <code>Runtime</code> is executed in its own virtual thread, isolated from the runtime one.</p> <p>See <code>Lifetime</code> for details when a <code>Runtime</code> will close.</p>"},{"location":"start/runtime/#threading-model","title":"Threading Model","text":"<p>JDA-Commands will listen for incoming events on the <code>JDA MainWS-ReadThread</code>. It will then create a new <code>Runtime</code> or use an existing one, depending on the type of event (see the flowchart below for details). The incoming event is  then passed to the corresponding <code>Runtime</code>.</p> <p>Each <code>Runtime</code> will run in its own virtual thread, called <code>JDAC Runtime-Thread &lt;UUID&gt;</code>. The <code>Runtime</code> will wait for new incoming events and then delegate them to the correct <code>EventHandler</code>. For instance, a <code>SlashCommandInteractionEvent</code> will be passed to the <code>SlashCommandHandler</code>.</p> <p>The <code>EventHandler</code> will again run in its own virtual thread, named <code>JDAC EventHandler-Thread &lt;UUID&gt;</code>, isolated from  the runtime one. Other incoming events are only executed when the previous one has finished. </p> <p>Blocking Methods</p> <p>Because each event has its own virtual thread, you can call blocking methods like JDAs <code>RestAction#complete</code> safely without blocking the <code>JDA MainWS-ReadThread</code>.</p> <p></p>"},{"location":"start/runtime/#lifetime","title":"Lifetime","text":"<p>By default, JDA-Commands will handle the lifetime of Runtimes for you. Every <code>Runtime</code> will be closed 15 minutes  after its creation. This time span is oriented towards the lifespan of the  <code>InteractionHook</code>. </p>"},{"location":"start/runtime/#explicit","title":"Explicit","text":"<p>You can disable the default behaviour by setting the  <code>ExpirationStrategy</code> to  <code>EXPLICIT</code>.</p> Main.java<pre><code>JDACommands.builder(jda, Main.class)\n        .expirationStrategy(ExpirationStrategy.EXPLICIT)\n        .start();\n</code></pre> <p>This will prevent any <code>Runtime</code> from closing until <code>closeRuntime</code> is explicitly called.</p> <p>Example</p> GreetCommand.java<pre><code>@SlashCommand(\"greet\")\npublic void onCommand(CommandEvent event) {\n    event.reply(\"Hello World!\");\n    event.closeRuntime();\n}\n</code></pre>"},{"location":"start/runtime/#inactivity","title":"Inactivity","text":"<p>You can also adjust the time frame for a <code>Runtime</code> to be closed.</p> <p>Example</p> <pre><code>JDACommands.builder(jda, Main.class)\n        .expirationStrategy(new ExpirationStrategy.Inactivity(20))//(1)!\n        .start();\n</code></pre> <ol> <li>Note: the duration is always passed as minutes.</li> </ol>"},{"location":"start/runtime/#components-and-modals","title":"Components and Modals","text":""},{"location":"start/runtime/#runtime-bound","title":"Runtime-bound","text":"<p>By default, Buttons, SelectMenus and Modals are <code>runtime-bound</code>. This means that any incoming event will use the same <code>Runtime</code> as the interaction that replied with them. </p> <p>However, this also means that they cannot be executed anymore after the <code>Runtime</code> is closed. JDA-Commands will handle  that case and remove the component. It will also send an ephemeral reply to the user, saying that the  component is no longer available.</p> <p></p> <p>You can customize this error message, find more about it here.</p>"},{"location":"start/runtime/#independent","title":"Independent","text":"<p>You can also reply with components that are <code>runtime-independent</code>, making them virtually immortal. They will create a new <code>Runtime</code> everytime they are executed. </p> <p>These components will even work after a full bot restart! If you want them to not be usable anymore you need to remove  them on your own.</p> <p>Info</p> <p>Modals cannot be independent because they always need a parent interaction that triggers them!</p> <p>Example</p> GreetCommand.java<pre><code>@SlashCommand(\"greet\")\npublic void onCommand(CommandEvent event) {\n    event.with().components(Component.independent(\"onButton\")).reply(\"Hello World!\");\n}\n</code></pre> <p>Read more about building replies here.</p>"}]}